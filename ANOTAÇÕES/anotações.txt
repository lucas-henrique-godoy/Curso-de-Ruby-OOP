CURSO DE RUBY
- Verificar o tipo do número usando o método class. Exemplo1- 23.class retona Interger. Exemplo2- 3.5.class retorna float.

- COMENTARIO DE 1 LINHA: #
- COMENTARIO DE VARIAS LINHAS: =begin codigo =end
- INTERPOLAÇÃO DE VARIÁVEIS: #{variavel}. Pra funcionar deve-se usar aspas duplas.

- GETS
O método gets é usado para ler uma linha de entrada do usuário. Quando você usa gets, o programa espera que o usuário digite algo e pressione Enter. O texto digitado pelo usuário é então retornado como uma string.

Exemplo:
print "Digite seu nome: "
nome = gets
puts "Olá, #{nome}!"

Se o usuário digitar "Ana" e pressionar Enter, o programa exibirá "Olá, Ana!" com um caractere de nova linha ao final da string "Ana".

- .CHOMP
O método .chomp é usado para remover o caractere de nova linha (\n) do final de uma string. Quando você usa gets, a string retornada inclui o caractere de nova linha no final, porque o Enter digitado pelo usuário é considerado parte da entrada. O método .chomp remove esse caractere.

Exemplo:
print "Digite seu nome: "
nome = gets.chomp
puts "Olá, #{nome}!"

Neste caso, se o usuário digitar "Ana" e pressionar Enter, a variável nome conterá "Ana" sem o caractere de nova linha no final, e o programa exibirá "Olá, Ana!" de forma mais limpa.
Resumindo
gets: Lê uma linha de entrada do usuário e inclui o caractere de nova linha.
.chomp: Remove o caractere de nova linha do final de uma string.
Você pode usar .chomp sempre que quiser processar a entrada do usuário sem a quebra de linha final, tornando o tratamento de strings mais simples e direto.

- .inspect= Ajuda a obter uma visão clara e detalhada de como os dados estão estruturados dentro de um objeto. Ex: como o método puts sempre gera umaquebra de linha, o .inspect mostra o \n na saida de uma variavel.

- TIPOS PRIMITIVOS: os tipos primitivos são as categorias básicas de dados que a linguagem oferece para representar valores e realizar operações. Embora Ruby seja uma linguagem orientada a objetos, onde tudo é um objeto, os tipos primitivos ainda são fundamentais para a programação. Aqui estão os principais tipos primitivos em Ruby:

Inteiros (Integer): Representam números inteiros, tanto positivos quanto negativos.
Exemplo: 42, -7

Números de ponto flutuante (Float): Representam números que possuem uma parte decimal.
Exemplo: 3.14, -0.001
Strings (String):

Representam sequências de caracteres.
Exemplo: "Olá, mundo!", 'Ruby'
Strings podem ser definidas usando aspas duplas (") ou aspas simples ('). Aspas duplas permitem interpolação de variáveis e escape de caracteres, enquanto aspas simples não.
Booleanos (TrueClass e FalseClass):

Representam valores lógicos: verdadeiro (true) e falso (false).
Exemplo: true, false
Em Ruby, qualquer valor que não seja false ou nil é considerado verdadeiro (truthy).
Nil (NilClass):

Representa a ausência de valor ou um valor nulo.
Exemplo: nil
É o único valor da classe NilClass e é usado para representar "nenhum valor" ou "nada".
Símbolos (Symbol):

Representam identificadores imutáveis e frequentemente utilizados como chaves em hashes ou para representar nomes e identificadores.
Exemplo: :nome, :idade
Características Importantes:
Imutabilidade: Em Ruby, alguns tipos primitivos são imutáveis. Por exemplo, strings podem ser mutáveis ou imutáveis dependendo de como são manipuladas (quando se usa métodos como << ou +=, a string pode ser alterada).

Objetos: Todos esses tipos primitivos são objetos em Ruby. Por exemplo, 42 é um objeto da classe Integer, e "Olá" é um objeto da classe String. Isso permite que você utilize métodos e funcionalidades de objetos para manipular esses tipos primitivos.

Conversão de Tipos: Ruby oferece métodos para converter entre diferentes tipos primitivos, como to_i, to_f, to_s, e to_sym. Por exemplo, "123".to_i converte a string "123" para o inteiro 123. Esses tipos primitivos são a base para a construção de expressões e estruturas de dados mais complexas em Ruby. Combinando-os, você pode criar variáveis, realizar cálculos, manipular texto e controlar o fluxo do seu programa.

- CONVERSÃO: 
.to_i converte para inteiro.
.to_f converte para float.
.to_s converte para string.

OPERADORES ARITMÉTICOS:
Adição (+)

Descrição: Soma dois números.
Exemplo: 5 + 3 resulta em 8.
Subtração (-)

Descrição: Subtrai o segundo número do primeiro.
Exemplo: 10 - 4 resulta em 6.
Multiplicação (*)

Descrição: Multiplica dois números.
Exemplo: 7 * 5 resulta em 35.
Divisão (/)

Descrição: Divide o primeiro número pelo segundo. Retorna um Float.
Exemplo: 10 / 4 resulta em 2.5.
Divisão Inteira (div)

Descrição: Divide o primeiro número pelo segundo e retorna o quociente inteiro.
Exemplo: 10.div(4) resulta em 2.
Módulo (%)

Descrição: Retorna o restante da divisão entre dois números.
Exemplo: 10 % 4 resulta em 2.
Potenciação (**)

Descrição: Eleva o primeiro número à potência do segundo.
Exemplo: 2 ** 3 resulta em 8.
Operadores Aritméticos Combinados
Adição Atribuição (+=)

Descrição: Adiciona e atribui o resultado à variável.
Exemplo: a += 3 é equivalente a a = a + 3.
Subtração Atribuição (-=)

Descrição: Subtrai e atribui o resultado à variável.
Exemplo: a -= 4 é equivalente a a = a - 4.
Multiplicação Atribuição (*=)

Descrição: Multiplica e atribui o resultado à variável.
Exemplo: a *= 5 é equivalente a a = a * 5.
Divisão Atribuição (/=)

Descrição: Divide e atribui o resultado à variável.
Exemplo: a /= 4 é equivalente a a = a / 4.
Módulo Atribuição (%=)

Descrição: Aplica o operador módulo e atribui o resultado à variável.
Exemplo: a %= 4 é equivalente a a = a % 4.
Potenciação Atribuição (**=)

Descrição: Eleva à potência e atribui o resultado à variável.
Exemplo: a **= 3 é equivalente a a = a ** 3.
Esses operadores são usados para realizar operações matemáticas básicas em Ruby e são bastante diretos para quem está familiarizado com operações aritméticas.

OPERADORES RELACIONAIS:
> maior
< menor
>= maior ou igual
<= menor ou igual
== igual
!= diferente

Operador spaceship <=>: m Ruby é conhecido como o operador "spaceship" ou operador de comparação, e é usado para realizar uma comparação entre dois valores. Este operador é bastante útil para determinar a ordem relativa entre dois elementos e é fundamental em muitas operações de ordenação e comparação.

Funcionamento do Operador <=>
O operador <=> retorna um valor inteiro que indica a relação entre os dois operandos:

Se o primeiro operando é menor que o segundo: Retorna -1.
Se o primeiro operando é igual ao segundo: Retorna 0.
Se o primeiro operando é maior que o segundo: Retorna 1.

EXEMPLO:
irb(main):019> 1 <=> 2
=> -1
irb(main):020> 2 <=> 2
=> 0
irb(main):021> 2 <=> 1
=> 1

OPERADORES DE ATRIBUIÇÃO:

Atribuição Simples (=): Atribui um valor à variável.
Atribuição Adicional (+=): Adiciona um valor à variável.
Atribuição Subtrativa (-=): Subtrai um valor da variável.
Atribuição Multiplicativa (*=): Multiplica a variável por um valor.
Atribuição Divisiva (/=): Divide a variável por um valor.
Atribuição de Módulo (%=): Calcula o módulo e atribui o resultado.
Atribuição de Potenciação (**=): Eleva a variável à potência de um valor.

OPERADORES DE INTERVALO: Servem para quando precisarmos ir de um número a outro.
No Ruby, os operadores de intervalo são usados para criar intervalos de valores. Eles são:
    .. (intervalo fechado): inclui o valor final. Exemplo: 1..5 representa os números de 1 a 5. (ou seja vai ate o ultimo elemento)
    ... (intervalo exclusivo): exclui o valor final. Exemplo: 1...5 representa os números de 1 a 4. (ou seja vai ate o penultimo elemento)

- ESTRUTURAS CONDICIONAIS: Em Ruby, estruturas condicionais são usadas para executar diferentes blocos de código dependendo de uma condição. Elas permitem que o programa tome decisões e siga diferentes caminhos de execução. Vamos explorar as principais estruturas condicionais do Ruby:

1. if
A estrutura básica de decisão. Executa um bloco de código se a condição for verdadeira.

if condição
  # código a ser executado se a condição for verdadeira
end
Exemplo:
idade = 18
if idade >= 18
  puts "Você é maior de idade."
end

2. else
Usado em conjunto com if. O bloco else é executado se a condição do if for falsa.
if condição
  # código se a condição for verdadeira
else
  # código se a condição for falsa
end
Exemplo:
idade = 16
if idade >= 18
  puts "Você é maior de idade."
else
  puts "Você é menor de idade."
end

3. elsif
Permite testar várias condições diferentes em sequência. Usado após um if e antes de um else.
if condição1
  # código se condição1 for verdadeira
elsif condição2
  # código se condição2 for verdadeira
else
  # código se nenhuma das condições anteriores for verdadeira
end
Exemplo:
nota = 85
if nota >= 90
  puts "Conceito A"
elsif nota >= 80
  puts "Conceito B"
elsif nota >= 70
  puts "Conceito C"
else
  puts "Conceito D"
end

4. case
Uma alternativa ao uso de múltiplos if...elsif. Avalia uma expressão e compara com várias possibilidades.
case expressão
when valor1
  # código se a expressão for igual a valor1
when valor2
  # código se a expressão for igual a valor2
else
  # código se nenhum dos valores anteriores corresponder
end
Exemplo:
dia_da_semana = "segunda-feira"
case dia_da_semana
when "segunda-feira"
  puts "Início da semana de trabalho."
when "sábado", "domingo"
  puts "Final de semana."
else
  puts "Dia útil."
end

5. unless
Executa um bloco de código se a condição for falsa. É o oposto de if.
unless condição
  # código a ser executado se a condição for falsa
end
Exemplo:
idade = 16
unless idade >= 18
  puts "Você é menor de idade."
end

6. ternário
Uma forma compacta de uma expressão if...else. É útil para atribuições rápidas.
condição ? valor_se_verdadeiro : valor_se_falso
Exemplo:
idade = 18
status = idade >= 18 ? "Maior de idade" : "Menor de idade"
puts status

7. if Modificado (Inline)
Permite executar uma expressão condicional de forma compacta.

# Código se a condição for verdadeira
puts "Você é maior de idade." if idade >= 18
8. unless Modificado (Inline)
Similar ao if modificado, mas para o caso de condição falsa.

# Código se a condição for falsa
puts "Você é menor de idade." unless idade >= 18
Essas estruturas fornecem flexibilidade para o controle de fluxo em Ruby, permitindo que o código reaja a diferentes condições de maneira eficiente.

- OPERADORES LÓGICOS:
&& and Funciona com 2 valores/condições
|| or Funciona com 2 valores/condições
! not Funicona apenas com 1 valor/condição

- ESTRUTURAS DE REPETIÇÃO:

WHILE: O loop while executa um bloco de código enquanto uma condição for verdadeira.
Sintaxe:
while condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5, e imprime os valores de i de 0 a 4.
i = 0
while i < 5
  puts i
  i += 1
end


UNTIL: O loop until é o oposto do while e executa um bloco de código enquanto a condição for falsa.
Sintaxe:
until condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5.
i = 0
until i >= 5
  puts i
  i += 1
end

-VETORES: vetores são conhecidos como arrays. Um array é uma coleção de elementos armazenados em uma única variável, permitindo o acesso e manipulação de dados de forma organizada. Aqui está uma explicação detalhada sobre como trabalhar com arrays em Ruby:

Criando Arrays
Você pode criar um array de várias maneiras:

# Criando um array vazio
empty_array = []

# Criando um array com alguns elementos
numbers = [1, 2, 3, 4, 5]
names = ["Alice", "Bob", "Charlie"]

# Criando um array com elementos de tipos diferentes
mixed_array = [1, "hello", 3.14, true]
Acessando Elementos
Os elementos em um array são acessados por índices, que começam em 0:

numbers = [10, 20, 30, 40, 50]
puts numbers[0]  # Saída: 10
puts numbers[2]  # Saída: 30
Você também pode usar índices negativos para acessar os elementos a partir do final do array:

puts numbers[-1]  # Saída: 50 (último elemento)
puts numbers[-2]  # Saída: 40 (penúltimo elemento)
Modificando Arrays
Você pode adicionar, remover e modificar elementos em um array:

# Adicionando elementos
numbers.push(60)        # Adiciona 60 ao final do array
numbers << 70           # Adiciona 70 ao final do array

# Removendo elementos
numbers.pop             # Remove o último elemento (70)
numbers.shift           # Remove o primeiro elemento (10)

# Modificando elementos
numbers[1] = 100        # Altera o segundo elemento para 100
Iterando Sobre Arrays
Você pode usar loops para iterar sobre os elementos de um array:

numbers = [1, 2, 3, 4, 5]

# Usando each para iterar
numbers.each do |number|
  puts number
end

# Usando um loop for
for number in numbers
  puts number
end
Métodos Comuns de Arrays
Aqui estão alguns métodos úteis para arrays em Ruby:

length ou size: Retorna o número de elementos no array.

puts numbers.length    # Saída: 5
puts numbers.size      # Saída: 5
include?: Verifica se um array contém um elemento específico.

puts numbers.include?(3)  # Saída: true
sort: Ordena os elementos do array.

sorted_numbers = numbers.sort
puts sorted_numbers       # Saída: [1, 2, 3, 4, 5]
map: Cria um novo array com os resultados de aplicar um bloco a cada elemento.

squared_numbers = numbers.map { |n| n * n }
puts squared_numbers       # Saída: [1, 4, 9, 16, 25]
select: Retorna um novo array contendo todos os elementos para os quais o bloco retorna verdadeiro.

even_numbers = numbers.select { |n| n.even? }
puts even_numbers          # Saída: [2, 4]
reject: Retorna um novo array contendo todos os elementos para os quais o bloco retorna falso.

odd_numbers = numbers.reject { |n| n.even? }
puts odd_numbers           # Saída: [1, 3, 5]
Conclusão
Arrays em Ruby são uma estrutura de dados fundamental que permite armazenar e manipular coleções de elementos de maneira eficiente. Você pode acessar, modificar e iterar sobre os elementos de arrays usando uma variedade de métodos e técnicas, o que facilita o trabalho com listas de dados em seus programas Ruby.

nome_do_array.push(valor) - Adiciona um valor na próxima posição do array.
nome_do_array.delete(valor) - Remove o valor especificado.
nome_do_vetor[posição]- Para ver o valor de uma determinada posição.

- HASHES: são uma estrutura de dados que armazena pares de chave-valor, onde cada chave é única e associada a um valor. Hashes são úteis para armazenar e acessar dados de forma eficiente. Eles são semelhantes a dicionários em outras linguagens de programação.

Criando Hashes
Você pode criar um hash de várias maneiras:

# Criando um hash vazio
empty_hash = {}

# Criando um hash com pares de chave-valor
person = {
  "name" => "Alice",
  "age" => 30,
  "city" => "New York"
}

# Usando símbolos como chaves (uma prática comum)
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}
Acessando e Modificando Valores
Para acessar ou modificar valores em um hash, você usa a chave correspondente:

person = { name: "Alice", age: 30, city: "New York" }

# Acessando um valor
puts person[:name]  # Saída: Alice

# Modificando um valor
person[:age] = 31
puts person[:age]   # Saída: 31

# Adicionando um novo par chave-valor
person[:occupation] = "Engineer"
puts person[:occupation]  # Saída: Engineer
Métodos Comuns de Hashes
Aqui estão alguns métodos úteis para trabalhar com hashes em Ruby:

keys: Retorna um array com todas as chaves do hash.

puts person.keys.inspect  # Saída: [:name, :age, :city, :occupation]
values: Retorna um array com todos os valores do hash.

puts person.values.inspect  # Saída: ["Alice", 31, "New York", "Engineer"]
each: Itera sobre cada par chave-valor no hash.

person.each do |key, value|
  puts "#{key}: #{value}"
end
# Saída:
# name: Alice
# age: 31
# city: New York
# occupation: Engineer
has_key?: Verifica se o hash contém uma chave específica.

puts person.has_key?(:age)  # Saída: true
puts person.has_key?(:salary)  # Saída: false
has_value?: Verifica se o hash contém um valor específico.

puts person.has_value?("Alice")  # Saída: true
puts person.has_value?(25)       # Saída: false
delete: Remove um par chave-valor do hash.

person.delete(:occupation)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"New York"}
merge: Mescla dois hashes, com o segundo hash sobrescrevendo valores do primeiro hash para chaves iguais.

new_info = { city: "San Francisco", email: "alice@example.com" }
person.merge!(new_info)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"San Francisco", :email=>"alice@example.com"}
Hashes e Símbolos
Usar símbolos como chaves é uma prática comum em Ruby, pois os símbolos são mais eficientes em termos de desempenho e memória comparados às strings:

# Usando símbolos como chaves
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}

# Acessando valores
puts person[:name]  # Saída: Alice
Hashes Aninhados
Você pode ter hashes dentro de hashes para representar estruturas de dados mais complexas:

people = {
  alice: { age: 30, city: "New York" },
  bob: { age: 25, city: "San Francisco" }
}
puts people[:alice][:city]  # Saída: New York

Conclusão
Hashes são uma ferramenta poderosa em Ruby para armazenar e organizar dados de forma eficiente. Eles permitem o acesso rápido a valores baseados em chaves e oferecem uma variedade de métodos para manipular e consultar os dados armazenados.

PRIMEIRA FORMA:
- criando um hash: h = { "a" => "123", "b" => "456" } 
- Acessando o valor de uma chave: h["a"].

SEGUNDA FORMA:
 - criando um hash: h = { a: "123", b: "456" }
 - Acessando o valor de uma chave: h[:a].

SÍMBOLOS: Definição 1: (São strings estáticas) 
Definição 2: Símbolos são objetos imutáveis e únicos que representam identificadores, nomes ou valores constantes. Usamos para criar hashes.

Sintaxe: Criados prefixando um nome com dois pontos (:), como :name, :age, :city.

Características:

Imutabilidade: Não podem ser alterados após a criação.
Identidade Única: Cada símbolo com o mesmo nome é o mesmo objeto na memória.
Eficiência: Comparações e armazenamento são mais eficientes do que para strings.
Usos Comuns:
Chaves de Hashes: Usados como chaves em hashes por sua eficiência.

person = { name: "Alice", age: 30, city: "New York" }
Parâmetros de Métodos: Representam opções ou parâmetros de métodos.

def greet(options = {})
  name = options[:name] || "Guest"
  puts "Hello, #{name}!"
end
Identificadores: Representam eventos ou mensagens.

event = :login_success
Comparação com Strings:

Imutabilidade: Strings podem ser alteradas, símbolos não.
Eficiência: Comparações e armazenamento são mais rápidos e econômicos para símbolos.
Exemplo de Comparação

# Comparando símbolos
symbol1 = :hello
symbol2 = :hello
puts symbol1.equal?(symbol2)  # Saída: true (mesmo objeto na memória)
Símbolos são ideais para representar valores constantes e identificadores devido à sua imutabilidade e eficiência.

.object_id - Retorna o endereço de memória de uma variável. EX: "Lucas".object_id -> Isso na primeira vez que foi executado retorna 13660, na segunda retornou 15500, ou seja o endereço sempre muda. Obs: se usarmos esse método com um símbolo, o endereço de memórianão muda.
Ex:
irb(main):009> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez.
irb(main):010> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez. 


-ITERADOR EACH (mais usado no ruby do que o for): é uma maneira simples e poderosa de percorrer elementos de coleções, como arrays e hashes, e realizar uma operação para cada elemento.

Como Funciona
Para Arrays: O método each passa cada elemento do array para um bloco de código.

array = [1, 2, 3]
array.each do |element|
  puts element
end
Saída:
1
2
3

Explicação: O bloco (do |element| ... end) é executado para cada elemento do array, e element representa o item atual do array.

Para Hashes: O método each passa cada par chave-valor do hash para um bloco de código.

hash = { a: 1, b: 2, c: 3 }
hash.each do |key, value|
  puts "#{key}: #{value}"
end
Saída:

makefile
Copiar código
a: 1
b: 2
c: 3
Explicação: O bloco (do |key, value| ... end) é executado para cada par chave-valor do hash, onde key é a chave e value é o valor correspondente.

Resumo
each é usado para iterar sobre todos os elementos de uma coleção.
Array: Passa cada elemento para o bloco.
Hash: Passa cada par chave-valor para o bloco.
Uso: Ideal para aplicar uma operação a cada item sem modificar a coleção original.

MEU EXEMPLO: Esse código pega a que é o elemento do array, passe em cada um deles, e quando for passar em cada um deles chame de element e depois imprima-o na tela.

PRIMEIRA FORMA INLINE:
a = [1,4,6,89,0]
a.each { |element| puts element } 

SEGUNDA FORMA:
a.each do |el|
   puts el
   puts el * 2
   puts el * 3
 end

-REPETIÇÕES FIXAS COM TIMES: Em Ruby, "repetições fixas com times" se refere ao uso do método times para executar um bloco de código um número fixo de vezes.

Aqui está um resumo de como funciona:

O método times é chamado em um número inteiro.
Esse método executa o bloco de código associado ao número de vezes especificado.
O bloco de código recebe o índice da iteração como um argumento, começando de 0 até n-1, onde n é o número especificado.
Exemplo básico:

# EXEMPLO DE COM SINTAXE PARA MULTIPLAS LINHAS
5.times do |i|
  puts "Iteração número #{i}"
end
Saída:

Iteração número 0
Iteração número 1
Iteração número 2
Iteração número 3
Iteração número 4
Neste exemplo, o bloco de código é executado 5 vezes, e o índice da iteração é passado como i, começando de 0 e indo até 4.
O times é útil para repetição simples e quando você precisa de um número fixo de iterações.

# EXEMPLOS COM SINTAXE PARA UMA LINHA ↓↓↓
OUTRO EXEMPLO SEM VARIÁVEL CONTADORA: 

# O método `times` é chamado no número 5.
# Isso significa que o bloco de código será executado 5 vezes.
5.times { puts "Lucas" }  # Em cada iteração, imprime a string "Lucas" no console

# Saída esperada:
# Lucas
# Lucas
# Lucas
# Lucas
# Lucas
#
# O método `times` executa o bloco o número de vezes especificado, 
# que neste caso é 5.

OUTRO EXEMPLO COM VARIÁVEL CONTADORA:

# O método `times` é chamado no número 5.
# O bloco de código será executado 5 vezes.
# A cada iteração, o índice da iteração é passado como variável `x`.

5.times do |x| 
  puts "#{x} - Lucas"  # Imprime o índice da iteração seguido por " - Lucas"
end

# Saída esperada:
# 0 - Lucas
# 1 - Lucas
# 2 - Lucas
# 3 - Lucas
# 4 - Lucas
#
# O método `times` executa o bloco o número de vezes especificado (5 vezes).
# A variável `x` representa o índice da iteração, começando de 0 e indo até 4.

Ou seja, executa um código numa quantidade determinada de vezes.  Nesse caso 5 vezes(5.times)

______________________________________________________________________________________________

ORIENTAÇÃO A OBJETOS: É  um paradigma para o desenvolvimento de software que baseia-se na utilização de componentes individuais (objetos) que colaboram para construir sistemas mais complexos. A colaboração entre os objetos é feita através do envio de mensagens(requisição de serviços). O paradigma de objetos baseia-se em alguns conceitos como: 
- Classes
- Objetos
- Encapsulamento
- Herança
- Polimorfismo 
- Entre outros.

FUNDAMENTOS: 
- Qualquer coisa é um objeto
- Objetos realizam tarefas através da requisição de serviços a outros objetos.
- Cada objeto pertence a uma determinada classe. Uma classe agrupa objetos similares.
- A classe é um repositório para comportamento associado ao objeto.
- Classes são organizadas em hierarquias.

PILARES:
- Abstração: Imaginar o objeto que tenham - Identidade única(ex nome), Atributos(características), Métodos(ações).
- Encapsulamento: Esconder as propriedades dos objetos para obter mais segurança.
- Herança: Permite o reúso de código.
- Polimorfismo: É a capacidade de referenciar um objeto de várias formas diferentes.

CLASSE: Uma classe é um gabarito para a definição de objetos. Através da definição de uma classe, descreve-se que propriedades/atributos e métodos/ações o objeto terá.
Em resumo uma classe representa um conjunto de objetos com características afins. Uma classe define o comportamento dos objetos através de seus métodos, e quais estados ele é capaz de manter através de seus atributos.

A partir da classe(forma/gabarito) eu posso gerar varios objetos "iguais". Quando eu gero esses objetos iguais, a única coisa que vai mudar entre eles é: quais atributos cada um vai ter, e quais são os métodos que els vão poder executar.

É possível especificar classes para entidades físicas, conceituais ou de software. EX:
- Entidade física: caminhão, carro, bicicleta, etc.
- Entidade Conceitual: processo químico, matrícula, etc.
- Entidade de Software: lista encadeada, arquivo, etc.

EXEMPLO: Uma classe lâmpada pode conter os atributos "potencia" e "voltagem", que são características comuns à todas as lâmpadas , e pode conter as ações "ligar" e "desligar", que também são características comuns.

Uma classe em programação é como um modelo que define as características e ações de seus objetos. Por exemplo, se criarmos uma classe chamada Pessoa, podemos gerar um objeto específico, como Lucas. Esse objeto tem atributos como nome, que será "Lucas", e pode ter outros atributos, como a cor dos olhos. Além disso, o objeto pode realizar ações definidas pela classe, como pular ou andar. Todos os objetos criados a partir dessa classe terão as mesmas características e ações básicas definidas no modelo da classe.

- Encapsulamento: Se refere a esconder os dados (atributos) dentro do objeto. Produz duas visões do obejto:
* Visão Interna(COMO o obejto faz).
* Visão Externa(O QUE o objeto faz).

Em se tratando de classes, o encapsulado é obtido através da vidibilidade, conhecida tambem como "modificadores de acesso". Os modificadores de acessos mais comuns são:

- public/público: Representado por um sinal de "+" na notaçãi UML. Elementos declarados como público podem ser acessados a partir de qualqueroutra classe.
- private/privado: Representado por um sinal de "-" na notação UML. Elementos private só podem ser acessados pela própria classe.
- protected/protegido: Representado por um sinal de sustenido "#" na notação UML. Elementos protected só podem ser acessados pela própria classe e por suas descendentes.

-EXEMPLO DE ENCAPSULAMENTO: O funcionamento interno de um telefone é escondido(ou encapsulado)do usuário. Para o usuário realizar uma chamada telefônica(visão externa) ele não precisa conhecer os detalhes da eletrônica utilizados no teelfone(visão interna).

-OBJETO: Classes são fábricas de objetos. Objetos são instâncias de uma classe, ou seja vieram de uma classe.
- INSTÂNCIA: uma instância é um objeto criado a partir de uma classe em programação orientada a objetos.

* Um objeto é capaz de armazenar estadOs através de seus atributos e reagir a mensagens enviadas a ele, assim como se relacionar e enviar mensagens a outros objetos.
* Um objeto é qualquer indivíduo, lugar, evento, coisa, tela, relatório ou conceito que seja aplicável ao sistema.
* Todo objeto pertence a uma determinada classe e possui atributos próprios.
* Os atributos são mutáveis e podem receber diferentes valores de acordo com as características do obejto.

A criação de um objeto consiste em sua instanciação, segundo, " cada instância tem seus próprios valores de atributos, mas compartilha o nome e os comportamentos dos atributos com as outras instâncias da classe.

Para definir uma classe, podemos tomar por base o Diagrama de Classe criado na última aula:

+--------------------------------+
|             Conta               |
+--------------------------------+
| - saldo: float                  |
| - numero: String                |
+--------------------------------+
| + debitar()                     |
| + creditar()                    |
| + transferir()                  |
| + consultarSaldo()              |
+--------------------------------+

Em ruby definimos uma classe da seguinte forma:
class Conta
  corpoDaClasse (atributos e métodos)
end

- Convenções a serem usadas: O nome da classe inicia-se com letra maiúscula e pára nomes compostos devemos usar o padrão CamelCase. Ex: NomeDaMinhaClasse.
O corpo de uma classe deve conter: Atributos, Metodos,  Construtor(método de inicialização).
Instanciando uma classe: 
* obj1 = Classe.new


Instanciando uma classe no irb:
PS C:\Users\lucas\OneDrive\Área de Trabalho\Curso-de-Ruby-OOP> irb
irb(main):001> require_relative "09-definindo_classes" 
=> true
irb(main):002> obj1 = Conta.new
=> #<Conta:0x000001acc8c622a0>
irb(main):003> obj1
=> #<Conta:0x000001acc8c622a0>
irb(main):004> obj1.class
=> Conta

Em ruy definimos um método da seguinte forma:
class Pessoa
  def gritar
    #corpo do método
  end
end

- Convenções a serem usadas: O nome do método inicia-se com letra minúscula e para nomes compostos devemos usar o padrão snake_case. EX: nome_do_meu_metodo.

- Métodos com parâmetros: 
def gritar(texto)
  puts texto
end

- Retorno do método:
def gritar(texto)
  return texto
end

Definindo Atributos

Variáveis de instância:

Variáveis de instância armazenam valores específicos para cada objeto em Ruby. Isso significa que cada instância de uma classe pode ter seus próprios valores distintos para essas variáveis. Em Ruby, essas variáveis são precedidas por um símbolo de arroba (@).

Por exemplo:

ruby
Copiar código
class Pessoa
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end

  def mostrar_informacoes
    puts "Nome: #{@nome}, Idade: #{@idade}"
  end
end

pessoa1 = Pessoa.new("Alice", 30)
pessoa2 = Pessoa.new("Bob", 25)

pessoa1.mostrar_informacoes  # Saída: Nome: Alice, Idade: 30
pessoa2.mostrar_informacoes  # Saída: Nome: Bob, Idade: 25
Neste exemplo, @nome e @idade são variáveis de instância. Cada objeto pessoa1 e pessoa2 tem seus próprios valores para essas variáveis, que são distintos e específicos para cada instância da classe Pessoa. Isso permite que cada objeto mantenha e gerencie seu próprio estado de maneira independente.
___________________________________________________________________________________________________________________

EXEMPLO DE EXPLICAÇÃO(MINHA) DO PROCESSO DE CRIAR E USAR UMA CLASSE EM RUBY : entao basicamente primeiro crio uma classe e inicializo as variáveis de instancia dentro do método initialize, depois crio os métodos que a classe ira realizar utilizando as variáveis de instancia.  Depois instancio os objetos passando os valores dos parâmetros e por ultimo mostro os valores dos objetos na tela.

___________________________________________________________________________________________________________________

GET - Pegar.
SET- Guardar.

- ACESSORES: No Ruby, acessores são métodos que permitem o acesso e a modificação dos atributos de uma classe. Eles são uma maneira conveniente de gerenciar o acesso a variáveis de instância e encapsular a lógica de leitura e escrita desses atributos.
Tipos de Acessores

    Leitura e Escrita Simples
        Leitura (attr_reader): Cria um método de leitura para uma variável de instância, permitindo que você acesse o valor dessa variável de fora da classe, mas não o modifique diretamente.
        Escrita (attr_writer): Cria um método de escrita para uma variável de instância, permitindo que você modifique o valor dessa variável de fora da classe, mas não leia o valor diretamente.
        Leitura e Escrita (attr_accessor): Cria métodos de leitura e escrita para uma variável de instância, permitindo tanto a leitura quanto a modificação do valor da variável de fora da classe.

    Métodos de Acesso Personalizados
        Além dos acessores automáticos, você pode definir métodos de acesso e modificação personalizados para adicionar lógica adicional ao acessar ou alterar os valores das variáveis de instância.

Exemplo de Uso

Aqui está um exemplo de como usar os acessores no Ruby:

ruby

class Pessoa
  # Definindo atributos de instância com acessores
  attr_accessor :nome, :idade

  # Método initialize para inicializar os atributos
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end
end

# Criando uma nova instância da classe Pessoa
pessoa = Pessoa.new("Lucas", 27)

# Usando os métodos de leitura e escrita criados automaticamente
puts pessoa.nome  # Saída: Lucas
puts pessoa.idade # Saída: 27

# Modificando os valores dos atributos
pessoa.nome = "Wendel"
pessoa.idade = 49

# Usando os métodos de leitura após modificação
puts pessoa.nome  # Saída: Wendel
puts pessoa.idade # Saída: 49

Explicação dos Acessores

    attr_reader
        Uso: attr_reader :nome
        O que faz: Cria um método chamado nome que retorna o valor da variável de instância @nome. Não cria um método para definir o valor de @nome.

    ruby

class Pessoa
  attr_reader :nome

  def initialize(nome)
    @nome = nome
  end
end

attr_writer

    Uso: attr_writer :nome
    O que faz: Cria um método chamado nome= que define o valor da variável de instância @nome. Não cria um método para ler o valor de @nome.

ruby

class Pessoa
  attr_writer :nome

  def initialize(nome)
    @nome = nome
  end
end

attr_accessor

    Uso: attr_accessor :nome
    O que faz: Cria tanto o método nome para leitura quanto o método nome= para escrita. Isso permite acessar e modificar a variável de instância @nome.

ruby

    class Pessoa
      attr_accessor :nome

      def initialize(nome)
        @nome = nome
      end
    end

Métodos de Acesso Personalizados

Se você precisar de lógica personalizada ao acessar ou modificar atributos, você pode definir métodos de acesso manualmente:

ruby

class Pessoa
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end

  def nome
    @nome
  end

  def nome=(novo_nome)
    @nome = novo_nome.upcase # Exemplo de lógica personalizada
  end

  def idade
    @idade
  end

  def idade=(nova_idade)
    @idade = nova_idade
  end
end

pessoa = Pessoa.new("Lucas", 27)
puts pessoa.nome         # Saída: LUCAS (nome convertido para maiúsculas)

Conclusão

Acessores no Ruby são uma maneira poderosa e concisa de gerenciar o acesso a variáveis de instância. Usando attr_reader, attr_writer, e attr_accessor, você pode rapidamente criar métodos para acessar e modificar atributos, enquanto métodos personalizados oferecem flexibilidade para adicionar lógica adicional ao acesso e modificação dos dados.


-MÉTODOS CONSTRUTORES OU MÉTODOS DE INICIALIZAÇÃO: SINTAXE:

class Pessoa
    def initialize(nome)
    @var_nome = nome
  end
end

Permitem inicializar um objeto com dados "padrão". É invocado automaticamente quando instanciamos e criamos um objeto, assim preenchendo os atributos. É possível passar quantos parâmetros voce quiser.


-HERANÇA ENTRE CLASSES: Conceito: Herança permite que uma classe (subclasse) herde métodos e atributos de outra classe (superclasse), facilitando a reutilização e organização do código.

Sintaxe Básica: Use < para definir que uma classe herda de outra.

ClasseFilha < ClassePai ou pode ser chamada de SubClass < SuperClass

- METHOD OVERRIDING: A sobrescrita de métodos (method Overriding permite o desenvolvedor reescrever um método que já existe na classe pai.)
Sobrescrever métodos da classe pai. Sobrescrita de métodos é um conceito em programação orientada a objetos onde uma subclasse fornece uma implementação específica para um método que já foi definido na sua superclasse. Isso permite que a subclasse altere o comportamento do método herdado para atender às suas necessidades específicas.
Como o Overriding é Usado no Código:

    Classe Base (Calculadora): Define um método somar que retorna a soma simples de dois números. Esta é a implementação padrão.

    Subclasse (CalculadoraFashion): Herda da classe Calculadora e sobrescreve o método somar. Em vez de apenas retornar a soma dos números, a nova implementação fornece uma string formatada que inclui a soma. Isso é feito para alterar o comportamento do método somar na subclasse para algo mais específico e descritivo.
        Antes da Sobrescrita: O método somar na Calculadora simplesmente retorna o resultado da adição.
        Após a Sobrescrita: O método somar na CalculadoraFashion retorna uma mensagem personalizada, que inclui o resultado da adição.

- BENEFÍCIOS DO OVERRIDING: Personalização: Permite que subclasses personalizem ou modifiquem o comportamento de métodos herdados sem alterar a implementação da classe base.
    Polimorfismo: Facilita o polimorfismo, onde o método chamado é determinado pelo tipo da instância do objeto em tempo de execução, permitindo que diferentes comportamentos sejam executados dependendo da classe do objeto.Em Resumo: No código fornecido, a sobrescrita de métodos é usada para alterar o comportamento do método somar quando chamado a partir de uma instância da CalculadoraFashion. Isso demonstra como você pode modificar ou estender a funcionalidade de uma classe base, oferecendo uma versão específica do método para a subclasse.

- SUPER: É uma palavra usada para invocar o método de mesmo nome na super classe.
Em Ruby, a palavra-chave super é utilizada dentro de um método para chamar o método correspondente da classe pai (ou superclasse). Isso é útil quando você está sobrescrevendo um método em uma subclasse e deseja adicionar ou modificar o comportamento do método da classe pai.O super serve basicamente para  invocar o método correspondente na classe pai.  

- SELF: Self é uma referência ao objeto que está executando o código no momento. No Ruby, o self é um conceito fundamental que se refere ao objeto atual no contexto em que um pedaço de código está sendo executado. Ele é usado para acessar e manipular o próprio objeto no qual o código está sendo executado. .É uma palavra reservada que da acesso ao objero corrente. Assim dizemos que ao usarmos o objeto.meth estamos enviando o método ao objeto, ou seja quer dizer que estamos enviando uma mensagem do método para o.
Dependendo do local o self vai ser diferente.

- MÉTODOS DE INSTÂNCIA vs MÉTODOS DE CLASSE:
Método de instância: Métodos de instância são definidos dentro de uma classe e operam sobre instâncias específicas dessa classe. Eles podem acessar e modificar os atributos de uma instância.

Como Funcionam
Definição: São definidos usando def dentro da classe, sem prefixo especial.

Acesso: Operam sobre um objeto específico e podem acessar os atributos dessa instância usando @atributo.

SINTAXE:
def method
      
end
__________________________________________________________________________________

Método de classe: Métodos de classe são definidos para a classe como um todo, e não para instâncias individuais. Eles são usados quando você deseja que um método pertença à classe em si, e não a um objeto específico da classe ou em alguns momentos voce só preisa classe como um repositório, como um local onde você vai armazenar algumas funções ou métodos,  e só para usar aquele médodo independenteda instância. Sempre que tiver a palavra self na declaração de um método, quer dizer temos um método de classe, e podemos chamar aquele método sem instânciar a classe(não é preciso usar o new pra depois utilizar aquele método específico).

Como Funcionam
Definição: São definidos usando def self.nome_do_metodo dentro da classe.

Acesso: Não podem acessar atributos de instância diretamente, mas podem acessar e modificar variáveis de classe e outras propriedades da classe.

SINTAXE:
def self.method
    
end

_____________________________________________________________________________________________________________________
- Constantes: Em Ruby são variáveis cujo valor não deve mudar após ser definido. Elas são representadas por nomes em maiúsculas e, por convenção, não devem ser alteradas. Por exemplo:
PI = 3.14159
Se você tentar modificar o valor de uma constante, Ruby irá gerar um aviso, mas a alteração ainda será permitida.
Exemplos de uso: 
1 - Configurações de Aplicação: Armazenam URLs, chaves de API, e outras configurações fixas.
2 - Valores Matemáticos: Definem constantes matemáticas como PI e e.
3 - Limites e Configurações: Como limites de tamanho, tempos de espera, ou valores padrão.


- Classes constantes:
 Classes constantes em Ruby são classes que são definidas como constantes, com nomes em maiúsculas. Elas são usadas para criar tipos de objetos e definir comportamentos específicos. Por exemplo:

class Car
  def drive
    puts "Vroom!"
  end
end
Aqui, Car é uma constante que representa a classe, e você pode criar instâncias dela e usar seus métodos.

Exemplos de uso: 
1 - Tipos de Usuário: Definem tipos ou roles de usuários, como administrador e visitante.
2 - Códigos de Status: Armazenam códigos de status HTTP ou outros códigos de resposta.
3 - Categorias ou Tipos de Dados: Definem categorias fixas para dados, como níveis de acesso ou tipos de produto.
____________________________________________________________________________________________

- Módulos: São similares a classes em relação ao fato de que também armazenam uma coleção de métodos, constantes, outras definições de módulos e classes.
Diferentemente das classes, você não pode criar objetos baseados em módulos nem pode criar módulos que herdam desse módulo, ou seja não é possivel criar um módulo e instanciar esse módulo para criar um objeto.
Módulos são um bom lugar para armazenar constantes em um local centralizado.

- Objetivos: Agem como namespaces, permitindo que você defina métodos cujos nomes não irão colidir com aqueles definidos em outras partes de um programa. Permitem também que você compartilhe funcionalidades entre classes.
____________________________________________________________________________________________
-MIXINS:(Mistura de classes e módulos) Permite que façamos uma pseudo herança múltipla. 

São uma forma poderosa e flexível de adicionar funcionalidades a classes sem a necessidade de usar herança. Mixins são usados para compartilhar comportamentos entre classes através da inclusão de módulos. Isso permite que você compartilhe código entre várias classes sem criar uma hierarquia complexa de herança.

Conceito de Mixins
Um mixin é basicamente um módulo que contém métodos e, opcionalmente, constantes. Esses módulos podem ser incluídos em classes para adicionar seus métodos e comportamentos a essas classes.

____________________________________________________________________________________________
- Duck Typing: é um conceito de programação que se refere à ideia de que, em vez de verificar o tipo de um objeto (como se ele é uma string, um número, etc.), você verifica se ele tem os métodos e comportamentos que você espera. A expressão vem da ideia de que, se algo "anda como um pato" e "faz quack como um pato", então, para os propósitos do seu código, você pode tratá-lo como um pato, independentemente de sua origem.

Por exemplo, se você tem uma função que espera um objeto que tenha um método voar, em vez de verificar se o objeto é especificamente um tipo de "pássaro", você só se preocupa em saber se o objeto tem o método voar. Se tiver, o código funciona, independente do tipo exato do objeto.

Em Ruby, o conceito de duck typing é bastante utilizado e é uma parte fundamental da filosofia da linguagem. Ruby é uma linguagem dinâmica e flexível, o que significa que o tipo de um objeto não é tão importante quanto os métodos e comportamentos que ele possui.

Aqui está um exemplo simplificado para ilustrar como o duck typing funciona em Ruby:

class Pato
  def quack
    puts "Quack!"
  end

  def voar
    puts "Estou voando!"
  end
end

class Aviao
  def voar
    puts "Estou voando!"
  end
end

def faz_voar(objeto)
  objeto.voar
end

pato = Pato.new
aviao = Aviao.new

faz_voar(pato)   # Saída: "Estou voando!"
faz_voar(aviao)  # Saída: "Estou voando!"
No exemplo acima, a função faz_voar espera um objeto que tenha o método voar. Não importa se o objeto é um Pato, um Aviao, ou qualquer outra coisa que implemente o método voar. O importante é que o objeto responda à mensagem voar.

Essa flexibilidade é o que caracteriza o duck typing: você foca no que o objeto pode fazer, em vez de em que tipo de objeto ele é.
____________________________________________________________________________________________

- OUTRA EXPLICAÇÃO: Vamos esclarecer a frase:

"Ao usarmos duck typing, fazemos polimorfismo através de métodos com a mesma assinatura."

Explicação:
Duck Typing: Duck typing é um conceito em linguagens de programação dinâmica que diz que o tipo ou a classe de um objeto não é tão importante quanto o comportamento que ele demonstra. A ideia é baseada na expressão "se parece um pato, nada como um pato e grasna como um pato, então deve ser um pato". Em termos de programação, isso significa que um objeto é tratado como um determinado tipo se ele implementar os métodos e comportamentos esperados, independentemente da sua classe real ou da herança.

Polimorfismo: Polimorfismo é uma característica da programação orientada a objetos que permite que métodos com o mesmo nome se comportem de maneira diferente, dependendo do tipo do objeto que os chama. Isso permite que você use a mesma interface (ou assinatura de método) para diferentes tipos de dados.

Métodos com a mesma assinatura: A "assinatura" de um método refere-se ao seu nome e aos tipos e número de seus parâmetros. No contexto do duck typing, dois métodos com a mesma assinatura são aqueles que têm o mesmo nome e parâmetros, mesmo que possam estar em classes diferentes ou não compartilhem uma herança comum.

Resumindo:
Quando usamos duck typing, estamos aproveitando o fato de que, desde que um objeto implemente os métodos esperados (ou seja, tenha a mesma assinatura), podemos tratá-lo de maneira semelhante a outros objetos que implementam esses métodos, mesmo que eles não sejam da mesma classe ou não tenham uma relação de herança direta. Assim, o polimorfismo é alcançado através da implementação de métodos com a mesma assinatura, independentemente da hierarquia de classes.
_____________________________________________________________________________________________

-RESUMO DOS PILARES DA PROGRAMAÇÃO ORIENTADA A OBJETOS:

ABSTRAÇÃO: Imaginar o objeto
- Identidade única
- Atributos
- Métodos.

ENCAPSULAMENTO: Esconder as propriedadesdos objetos para obter mais segurança.
- attr_accessor
- attr_reader
- attr_writer

HERANÇA: A partir de uma classe pai ter uma classe filho herdando os atributos e métodos gerndo asim objetos permitindo reúso de código.
classe filha < classe pai


POLIMORFISMO: É a capacidade de referenciar um objeto de várias formas diferentes.
- Overriding
- Duck typing

- REABRINDO CLASSES (Monkey Patch): Em Ruby, você pode reabrir classes existentes e adicionar novos métodos sempre que precisar. Isso é uma das características dinâmicas da linguagem e pode ser muito útil para estender a funcionalidade de classes sem modificar o código original. Aqui está um guia básico para você entender como fazer isso:

1. Reabrir uma Classe
Para reabrir uma classe e adicionar novos métodos, você simplesmente declara a classe novamente com a mesma nomeação. Isso é conhecido como "abertura de classe" (class reopening). Aqui está um exemplo simples:

class Pessoa
  def initialize(nome)
    @nome = nome
  end

  def saudacao
    "Olá, meu nome é #{@nome}"
  end
end

# Reabrindo a classe Pessoa
class Pessoa
  def idade(idade)
    @idade = idade
  end

  def mostrar_idade
    "Eu tenho #{@idade} anos"
  end
end

# Criando uma nova instância e usando os novos métodos
pessoa = Pessoa.new("João")
puts pessoa.saudacao           # Saída: Olá, meu nome é João
pessoa.idade(30)
puts pessoa.mostrar_idade      # Saída: Eu tenho 30 anos
2. Adicionar Novos Métodos
Você pode adicionar métodos em qualquer momento durante a execução do programa, após a classe ter sido definida originalmente. Isso pode ser feito dentro da reabertura da classe, como mostrado acima.

3. Alterar Métodos Existentes
Se você reabrir uma classe e definir um método com o mesmo nome de um método existente, o novo método substituirá o método antigo. Aqui está um exemplo:

ruby
Copiar código
class Pessoa
  def saudacao
    "Oi!"
  end
end

# Reabrindo a classe e alterando o método saudacao
class Pessoa
  def saudacao
    "Olá, eu sou uma pessoa!"
  end
end

# Criando uma nova instância e usando o método alterado
pessoa = Pessoa.new("Maria")
puts pessoa.saudacao  # Saída: Olá, eu sou uma pessoa!
4. Usar Módulos para Extensão
Além de reabrir classes, você pode usar módulos para adicionar funcionalidades de forma mais modular e organizável. Aqui está um exemplo:

module Adicional
  def habilidades
    "Tenho habilidades adicionais!"
  end
end

class Pessoa
  include Adicional
end

pessoa = Pessoa.new("Ana")
puts pessoa.habilidades  # Saída: Tenho habilidades adicionais!
5. Considerações
Cuidado com sobrecarga: Reabrir classes e alterar métodos existentes pode levar a problemas de manutenção, especialmente em projetos grandes. É uma prática que deve ser usada com cuidado e consciência das implicações.
Testes: Sempre teste as alterações para garantir que a nova funcionalidade não afete negativamente o comportamento existente.

_____________________________________________________________________________________________

- REABRINDO CLASSES NO IRB:O IRB (Interactive Ruby) é uma ferramenta muito útil para experimentar e aprender Ruby interativamente. Vou mostrar como você pode usar o IRB para reabrir classes e adicionar métodos, de maneira semelhante ao que fizemos anteriormente, mas de forma interativa.

1. Iniciar o IRB
Primeiro, abra seu terminal e inicie o IRB digitando:

irb
2. Definir uma Classe e Adicionar Métodos
Vamos definir uma classe Pessoa e adicionar alguns métodos a ela. No IRB, você pode digitar o seguinte:

irb(main):001:0> class Pessoa
irb(main):002:1>   def initialize(nome)
irb(main):003:2>     @nome = nome
irb(main):004:2>   end
irb(main):005:1> 
irb(main):006:1*   def saudacao
irb(main):007:2>     "Olá, meu nome é #{@nome}"
irb(main):008:1>   end
irb(main):009:1> end
=> nil
Aqui, você criou uma classe Pessoa com um método saudacao.

3. Reabrir a Classe e Adicionar Métodos
Agora, reabra a classe Pessoa para adicionar mais métodos:

irb(main):010:0> class Pessoa
irb(main):011:1>   def idade(idade)
irb(main):012:2>     @idade = idade
irb(main):013:1>   end
irb(main):014:1> 
irb(main):015:1*   def mostrar_idade
irb(main):016:2>     "Eu tenho #{@idade} anos"
irb(main):017:1>   end
irb(main):018:1> end
=> nil
Aqui, você adicionou os métodos idade e mostrar_idade.

4. Usar a Nova Funcionalidade
Crie uma instância da classe Pessoa e use os novos métodos:

irb(main):019:0> pessoa = Pessoa.new("João")
=> #<Pessoa:0x00007f9d81043800 @nome="João">
irb(main):020:0> pessoa.saudacao
=> "Olá, meu nome é João"
irb(main):021:0> pessoa.idade(30)
=> 30
irb(main):022:0> pessoa.mostrar_idade
=> "Eu tenho 30 anos"
5. Alterar Métodos Existentes
Se você quiser alterar um método existente, reabra a classe e redefine o método:

irb(main):023:0> class Pessoa
irb(main):024:1>   def saudacao
irb(main):025:2>     "Oi, eu sou uma pessoa!"
irb(main):026:1>   end
irb(main):027:1> end
=> nil
Agora, se você chamar o método saudacao, verá a nova definição:

irb(main):028:0> pessoa.saudacao
=> "Oi, eu sou uma pessoa!"
6. Usar Módulos para Adicionar Funcionalidade
Você também pode usar módulos para adicionar métodos a uma classe. Vamos adicionar um módulo Adicional e incluir esse módulo na classe Pessoa:

ruby
Copiar código
irb(main):029:0> module Adicional
irb(main):030:1>   def habilidades
irb(main):031:2>     "Tenho habilidades adicionais!"
irb(main):032:1>   end
irb(main):033:1> end
=> nil
irb(main):034:0> class Pessoa
irb(main):035:1>   include Adicional
irb(main):036:1> end
=> nil
irb(main):037:0> pessoa.habilidades
=> "Tenho habilidades adicionais!"
No IRB, você pode experimentar e ver os efeitos das mudanças em tempo real, o que é ótimo para entender como a reabertura de classes e a inclusão de módulos funcionam na prática.

-OBS: Devemos tomar cuidado ao modificar um método padrão do ruby, pois interferir de forma errada no meu sistema.
_____________________________________________________________________________________________

-SPLIT: Em Ruby, o método split é utilizado para dividir uma string em um array de substrings, com base em um delimitador especificado.

Aqui está uma visão geral de como funciona: 
- Sintaxe Básica: string.split(delimitador, limite)

delimitador: É o padrão que você usa para separar a string. Pode ser uma string, um caractere ou uma expressão regular. Se você não fornecer um delimitador, o método usará espaços em branco por padrão.
limite (opcional): Define o número máximo de substrings a serem retornadas. Se você especificar um limite, a última substring conterá o restante da string original, mesmo que ela contenha o delimitador.
Exemplos

Dividindo uma string com base em um espaço:
string = "ola mundo ruby"
resultado = string.split
# resultado: ["ola", "mundo", "ruby"]

Dividindo uma string com base em um caractere específico:
string = "maçã,banana,laranja"
resultado = string.split(',')
# resultado: ["maçã", "banana", "laranja"]

Dividindo uma string com base em uma expressão regular:
string = "maçã;banana,laranja"
resultado = string.split(/[,;]/)
# resultado: ["maçã", "banana", "laranja"]

Usando o parâmetro limite:
string = "a-b-c-d"
resultado = string.split('-', 3)
# resultado: ["a", "b", "c-d"]

Neste último exemplo, o limite é 3, então a string é dividida em três partes, com a última parte contendo o restante da string.

Notas Adicionais
Se o delimitador não for encontrado na string, o método split retornará um array com a string original como seu único elemento.
Se o delimitador for uma expressão regular que pode coincidir com várias ocorrências consecutivas, o método split pode resultar em elementos vazios no array.
Por exemplo:

string = "a--b---c"
resultado = string.split('-')
# resultado: ["a", "", "b", "", "", "c"]
Neste exemplo, há elementos vazios no resultado porque o delimitador "-" aparece várias vezes consecutivamente.


POR PADRÃO ELE SÓ SEPARA AS PALAVRAS QUANDO TEM ESPAÇO ENTRE ELAS POIS O ESPAÇO É O DELIMITADOR. EXEMPLO NO IRB:
irb(main):001> "lucas godoy".split
=> ["lucas", "godoy"]

SE HÁ APENAS UMA PALAVRA ELE SIMPLESMENTE A COLOCA NUM ARRAY. EXEMPLO NO IRB:
irb(main):004> "lucas".split
=> ["lucas"]

- SEPARANDO LETRA POR LETRA. EXEMPLO NO IRB:
irb(main):006> "lucas".split("") - as aspas indicam que não tem nada(nenhum delimitador).
=> ["l", "u", "c", "a", "s"]      OBS: aspas simples tambem funcionam.

 - OUTRO EXEMPO:
irb(main):008> "fulano/de/tal/ok".split("")
=> ["f", "u", "l", "a", "n", "o", "/", "d", "e", "/", "t", "a", "l", "/", "o", "k"]

- OUTRO EXEMPLO AGORA USANDO A / COMO DELIMITADOR:
irb(main):009> "fulano/de/tal/ok".split("/")
=> ["fulano", "de", "tal", "ok"]

____________________________________________________________________________________________
- GEMS(gerenciador de pacotes do ruby): No Ruby, gems são pacotes de código reutilizável que você pode adicionar ao seu projeto para estender suas funcionalidades. Gems são uma parte fundamental do ecossistema Ruby e facilitam a inclusão de bibliotecas e ferramentas desenvolvidas por outros.

O que é uma Gem?
Uma gem é um arquivo compactado que contém um conjunto de arquivos Ruby, metadados (como nome, versão e descrição) e um arquivo de configuração chamado gemspec. As gems podem incluir bibliotecas, frameworks, ferramentas e até mesmo scripts de execução.

Componentes de uma Gem
Código Fonte: O código Ruby que a gem fornece.
Gemspec: Arquivo que descreve a gem, incluindo suas dependências e informações de versão.
Documentação: Pode incluir arquivos README e outros documentos.
Dependências: Outras gems ou bibliotecas necessárias para que a gem funcione corretamente.

Instalando e Usando Gems
Instalação: Para instalar uma gem, você usa o comando gem install. Por exemplo:
gem install rails
Isso instala a gem "rails" no seu sistema.

Adicionando ao Projeto: Em projetos Ruby, especialmente em aplicações Rails, você lista suas gems no arquivo Gemfile e usa o Bundler para gerenciar e instalar essas gems:

# Gemfile
gem 'rails', '~> 7.0'
gem 'nokogiri'
Para instalar as gems listadas no Gemfile, você executa:
bundle install

Usando Gems no Código: Após a instalação, você pode requerer e usar as funcionalidades da gem no seu código Ruby. Por exemplo, para usar a gem nokogiri:

require 'nokogiri'

doc = Nokogiri::HTML("<html><body>Hello World</body></html>")
puts doc.at('body').text

Encontrando e Explorando Gems
RubyGems.org: O principal repositório de gems Ruby. Você pode pesquisar e explorar gems aqui.

Command-line: Use gem search para procurar gems no terminal:

gem search '^rails$' --remote
Atualizando Gems
Para atualizar uma gem específica, você pode usar:

gem update nome_da_gem

Ou, para atualizar todas as gems no seu projeto:
bundle update

Conclusão
Gems são uma maneira poderosa e eficiente de adicionar funcionalidades e ferramentas ao seu projeto Ruby. Elas permitem que você aproveite o trabalho da comunidade Ruby e foque mais no desenvolvimento do seu próprio código.

OBS: PARA UTILIZAR UMA GEM É NECESSÁRIO INSTALAR: GEM INSTALL NOME DA GEM.
CARREGAR A GEM: REQUIRE "NOME DA GEM". EXEMPLO COM O  TERMINAL E IRB:
PS C:\Users\lucasgodoy\Desktop\Curso-de-Ruby-OOP> gem install lerolero_generator
Fetching lerolero_generator-1.0.1.gem
Using rubygems directory: C:/Users/lucasgodoy/.local/share/gem/ruby/3.3.0
Successfully installed lerolero_generator-1.0.1
Parsing documentation for lerolero_generator-1.0.1
Installing ri documentation for lerolero_generator-1.0.1
Done installing documentation for lerolero_generator after 0 seconds
1 gem installed
PS C:\Users\lucasgodoy\Desktop\Curso-de-Ruby-OOP> irb
irb(main):001> require "lerolero_generator"
=> true
irb(main):002> LeroleroGenerator.sentence
=> "Por outro lado, a execução deste projeto facilita a definição dos conceitos de participação geral."
irb(main):003>

-OBS: PARA INSTALAR UMA GEM: gem install <gem>
PARA DESINSTALAR UMA GEM: gem uninstall <gem>

____________________________________________________________________________________________

- BUNDLE(é também ua gem): Ele é usado para gerenciar quais as gems necessárias nos projetos.
O Bundler é um gerenciador de dependências para projetos Ruby. Ele lida com a instalação, atualização e gerenciamento das gems que seu projeto usa, garantindo que todas as dependências sejam consistentes e compatíveis com a versão especificada.

Principais Funcionalidades do Bundler
Gerenciamento de Dependências:

Especificação das Dependências: Você define as gems e suas versões em um arquivo chamado Gemfile.
Instalação das Dependências: O Bundler instala todas as gems listadas no Gemfile.
Isolamento de Dependências:

Ambiente Isolado: O Bundler cria um ambiente isolado para as dependências do projeto, evitando conflitos entre diferentes projetos e versões de gems.
Reproduzibilidade:

Bloqueio de Versões: Usa um arquivo chamado Gemfile.lock para garantir que todos os desenvolvedores e ambientes de produção usem as mesmas versões das gems.
Como Configurar e Usar o Bundler

1. Instalando o Bundler
Para instalar o Bundler, execute o seguinte comando:
gem install bundler

2. Criando um Gemfile
O Gemfile é um arquivo onde você lista todas as gems que seu projeto precisa. Crie um arquivo chamado Gemfile no diretório raiz do seu projeto com o seguinte conteúdo:

source 'https://rubygems.org'

gem 'rails', '6.1.0'
gem 'pg', '1.2.3'
gem 'puma', '~> 5.0'

source: Define o repositório de onde as gems serão baixadas.
gem: Lista as gems que seu projeto precisa e especifica suas versões.

3. Instalando Dependências
Depois de criar o Gemfile, você pode instalar as dependências usando:
bundle install
Esse comando faz o seguinte:

Baixa e instala as gems listadas no Gemfile.
Cria um arquivo Gemfile.lock que registra as versões exatas das gems instaladas, garantindo consistência.

4. Atualizando Gems
Para atualizar as gems para as versões mais recentes permitidas pelas restrições no Gemfile, use:

bundle update
Isso atualiza as gems e o Gemfile.lock conforme necessário.

5. Usando Gems no Código
Com o Bundler, você pode usar as gems no seu código Ruby sem se preocupar com o carregamento manual. Em vez de usar require 'nome_da_gem' diretamente, você usa o Bundler para garantir que a gem está carregada. Em um script Ruby, você deve incluir o Bundler no início:

require 'bundler/setup'
Bundler.require(:default)

# Agora você pode usar as gems listadas no Gemfile
6. Executando Comandos com Bundler
Se você deseja executar um comando que depende das gems do seu Gemfile, use bundle exec. Por exemplo:

bundle exec rails server

Isso garante que o comando seja executado com as versões das gems especificadas no Gemfile.lock.

Exemplo Completo

1. Crie um Gemfile:

source 'https://rubygems.org'

gem 'sinatra'
gem 'json', '~> 2.5'

2. Instale as dependências:

bundle install

3. Crie um arquivo Ruby app.rb:

require 'bundler/setup'
Bundler.require(:default)

require 'sinatra'
require 'json'

get '/' do
  { message: 'Hello, world!' }.to_json
end

4. Execute o script com Bundler:

bundle exec ruby app.rb

Conclusão
O Bundler é uma ferramenta poderosa para gerenciar dependências em projetos Ruby. Ele ajuda a garantir que todos os desenvolvedores e ambientes de produção estejam usando as mesmas versões das gems, o que reduz problemas de compatibilidade e facilita a manutenção do projeto. Ao seguir as etapas para criar um Gemfile, instalar e atualizar gems, e usar bundle exec para executar comandos, você pode gerenciar dependências de forma eficaz e manter seu projeto Ruby organizado e confiável.

- TRABALHANDO COM ARQUIVOS: Trabalhar com arquivos no Ruby é uma tarefa comum e pode ser feito de maneira simples e eficiente. O Ruby fornece uma API robusta para manipulação de arquivos, incluindo leitura, escrita, e manipulação de diretórios. Vou explicar os conceitos básicos e algumas operações comuns.

1. Abrindo Arquivos
Para abrir arquivos, você usa o método File.open. Este método pode receber dois argumentos principais:

Nome do Arquivo: O caminho para o arquivo que você deseja abrir.

Modo de Abertura: Especifica como o arquivo será aberto. Alguns modos comuns são:

'r' - Leitura (Read): Abre o arquivo para leitura.
'w' - Escrita (Write): Abre o arquivo para escrita. Se o arquivo já existir, ele será truncado.
'a' - Anexar (Append): Abre o arquivo para escrita, mas não apaga o conteúdo existente. Os dados são adicionados ao final do arquivo.
'r+' - Leitura e Escrita (Read and Write): Abre o arquivo para leitura e escrita. O arquivo deve existir.
2. Lendo Arquivos
Você pode ler arquivos de várias maneiras:

File.read: Lê o conteúdo inteiro do arquivo como uma string.

ruby
Copiar código
content = File.read('arquivo.txt')
puts content
File.open com bloco: Abre o arquivo e lê linha por linha dentro de um bloco.

ruby
Copiar código
File.open('arquivo.txt', 'r') do |file|
  file.each_line do |line|
    puts line
  end
end
IO#readlines: Lê todas as linhas do arquivo em um array.

ruby
Copiar código
lines = File.readlines('arquivo.txt')
puts lines
3. Escrevendo em Arquivos
Para escrever em arquivos, você pode usar métodos diferentes dependendo de como você abre o arquivo:

File.open com bloco: Abre o arquivo e escreve dados dentro de um bloco.

ruby
Copiar código
File.open('arquivo.txt', 'w') do |file|
  file.puts "Linha 1"
  file.puts "Linha 2"
end
File.write: Escreve dados no arquivo. Substitui o conteúdo existente se o arquivo já existir.

ruby
Copiar código
File.write('arquivo.txt', "Linha 1\nLinha 2")
4. Manipulando Arquivos
Verificar se um arquivo existe:

ruby
Copiar código
if File.exist?('arquivo.txt')
  puts 'O arquivo existe.'
else
  puts 'O arquivo não existe.'
end
Excluir um arquivo:

ruby
Copiar código
File.delete('arquivo.txt') if File.exist?('arquivo.txt')
Renomear um arquivo:

ruby
Copiar código
File.rename('arquivo.txt', 'novo_arquivo.txt')
Copiar um arquivo: Para copiar um arquivo, você pode usar o método FileUtils.cp da biblioteca fileutils.

ruby
Copiar código
require 'fileutils'
FileUtils.cp('arquivo.txt', 'arquivo_copiado.txt')
5. Trabalhando com Diretórios
Criar um diretório:

ruby
Copiar código
Dir.mkdir('novo_diretorio') unless Dir.exist?('novo_diretorio')
Listar arquivos em um diretório:

ruby
Copiar código
Dir.foreach('.') do |file|
  puts file
end
Excluir um diretório:

ruby
Copiar código
Dir.rmdir('novo_diretorio') if Dir.exist?('novo_diretorio')
Exemplo Completo
Aqui está um exemplo que cobre a abertura, leitura, escrita e fechamento de um arquivo:

ruby
Copiar código
# Abrir um arquivo para escrita
File.open('exemplo.txt', 'w') do |file|
  file.puts 'Esta é a primeira linha.'
  file.puts 'Esta é a segunda linha.'
end

# Ler o arquivo
File.open('exemplo.txt', 'r') do |file|
  file.each_line do |line|
    puts line
  end
end
Conclusão
Ruby oferece uma maneira bastante intuitiva para trabalhar com arquivos e diretórios. A chave é entender os modos de abertura de arquivos e como usar blocos para garantir que os arquivos sejam fechados corretamente após a operação. Utilize os métodos fornecidos para ler, escrever, manipular e gerenciar arquivos de forma eficaz.
____________________________________________________________________________________________________________________

- ARGV(é o que vem de fora da sua aplicação) - ARGUMENT VECTOR: Em Ruby, ARGV é uma constante que representa um array contendo os argumentos de linha de comando passados para o script Ruby. Quando você executa um script Ruby a partir da linha de comando e fornece argumentos, esses argumentos são armazenados na constante ARGV.

Como Funciona o ARGV
Quando você executa um script Ruby, qualquer argumento que você forneça depois do nome do script é capturado por ARGV. Os argumentos são armazenados em uma lista, onde cada elemento da lista é uma string representando um dos argumentos.

Exemplo
Considere um arquivo Ruby chamado exemplo.rb com o seguinte conteúdo:

# exemplo.rb
puts "Argumentos passados:"
ARGV.each_with_index do |arg, index|
  puts "Argumento #{index + 1}: #{arg}"
end
Se você executar este script a partir da linha de comando assim:

ruby exemplo.rb primeiro segundo terceiro
A saída será:

Argumentos passados:
Argumento 1: primeiro
Argumento 2: segundo
Argumento 3: terceiro
Detalhes sobre ARGV
Tipo de Dados: ARGV é um array de strings. Cada argumento é tratado como uma string, mesmo que você passe números ou outros tipos de dados.

Número de Argumentos: O número de argumentos pode ser obtido usando o método length ou size do array ARGV.

puts "Número de argumentos: #{ARGV.length}"
Manipulação de Argumentos: Você pode acessar cada argumento individualmente usando a notação de índice do array. Por exemplo, ARGV[0] acessa o primeiro argumento.

if ARGV.length > 0
  puts "O primeiro argumento é: #{ARGV[0]}"
end
Uso Comum: ARGV é frequentemente usado para passar parâmetros e opções para scripts Ruby, como nomes de arquivos, configurações, e outros dados necessários para a execução do script.

Exemplos de Uso
Ler Arquivo Especificado pelo Usuário

# ler_arquivo.rb
if ARGV.length != 1
  puts "Uso: ruby ler_arquivo.rb <nome_do_arquivo>"
  exit
end

arquivo = ARGV[0]

if File.exist?(arquivo)
  File.open(arquivo, 'r') do |f|
    puts f.read
  end
else
  puts "Arquivo não encontrado: #{arquivo}"
end
Executando:

ruby ler_arquivo.rb teste.txt
Passar Opções para o Script

# script_com_opcoes.rb
if ARGV.include?('--help')
  puts "Uso: ruby script_com_opcoes.rb [opções]"
  puts "--help: Mostra esta mensagem de ajuda"
  puts "--version: Mostra a versão do script"
  exit
end

if ARGV.include?('--version')
  puts "Versão 1.0.0"
  exit
end

puts "Executando script com argumentos: #{ARGV.join(', ')}"
Executando:

ruby script_com_opcoes.rb --version

Resumo
ARGV é um array de strings que contém os argumentos de linha de comando passados para um script Ruby.
É útil para permitir que scripts Ruby recebam entrada de parâmetros na linha de comando.
Cada argumento é acessado como uma string e você pode iterar sobre eles, verificar seu número, e manipulá-los conforme necessário.









