CURSO DE RUBY
- Verificar o tipo do número usando o método class. Exemplo1- 23.class retona Interger. Exemplo2- 3.5.class retorna float.

- COMENTARIO DE 1 LINHA: #
- COMENTARIO DE VARIAS LINHAS: =begin codigo =end
- INTERPOLAÇÃO DE VARIÁVEIS: #{variavel}. Pra funcionar deve-se usar aspas duplas.

- GETS
O método gets é usado para ler uma linha de entrada do usuário. Quando você usa gets, o programa espera que o usuário digite algo e pressione Enter. O texto digitado pelo usuário é então retornado como uma string.

Exemplo:
print "Digite seu nome: "
nome = gets
puts "Olá, #{nome}!"

Se o usuário digitar "Ana" e pressionar Enter, o programa exibirá "Olá, Ana!" com um caractere de nova linha ao final da string "Ana".

- .CHOMP
O método .chomp é usado para remover o caractere de nova linha (\n) do final de uma string. Quando você usa gets, a string retornada inclui o caractere de nova linha no final, porque o Enter digitado pelo usuário é considerado parte da entrada. O método .chomp remove esse caractere.

Exemplo:
print "Digite seu nome: "
nome = gets.chomp
puts "Olá, #{nome}!"

Neste caso, se o usuário digitar "Ana" e pressionar Enter, a variável nome conterá "Ana" sem o caractere de nova linha no final, e o programa exibirá "Olá, Ana!" de forma mais limpa.
Resumindo
gets: Lê uma linha de entrada do usuário e inclui o caractere de nova linha.
.chomp: Remove o caractere de nova linha do final de uma string.
Você pode usar .chomp sempre que quiser processar a entrada do usuário sem a quebra de linha final, tornando o tratamento de strings mais simples e direto.

- .inspect= Ajuda a obter uma visão clara e detalhada de como os dados estão estruturados dentro de um objeto. Ex: como o método puts sempre gera umaquebra de linha, o .inspect mostra o \n na saida de uma variavel.

- TIPOS PRIMITIVOS: os tipos primitivos são as categorias básicas de dados que a linguagem oferece para representar valores e realizar operações. Embora Ruby seja uma linguagem orientada a objetos, onde tudo é um objeto, os tipos primitivos ainda são fundamentais para a programação. Aqui estão os principais tipos primitivos em Ruby:

Inteiros (Integer): Representam números inteiros, tanto positivos quanto negativos.
Exemplo: 42, -7

Números de ponto flutuante (Float): Representam números que possuem uma parte decimal.
Exemplo: 3.14, -0.001
Strings (String):

Representam sequências de caracteres.
Exemplo: "Olá, mundo!", 'Ruby'
Strings podem ser definidas usando aspas duplas (") ou aspas simples ('). Aspas duplas permitem interpolação de variáveis e escape de caracteres, enquanto aspas simples não.
Booleanos (TrueClass e FalseClass):

Representam valores lógicos: verdadeiro (true) e falso (false).
Exemplo: true, false
Em Ruby, qualquer valor que não seja false ou nil é considerado verdadeiro (truthy).
Nil (NilClass):

Representa a ausência de valor ou um valor nulo.
Exemplo: nil
É o único valor da classe NilClass e é usado para representar "nenhum valor" ou "nada".
Símbolos (Symbol):

Representam identificadores imutáveis e frequentemente utilizados como chaves em hashes ou para representar nomes e identificadores.
Exemplo: :nome, :idade
Características Importantes:
Imutabilidade: Em Ruby, alguns tipos primitivos são imutáveis. Por exemplo, strings podem ser mutáveis ou imutáveis dependendo de como são manipuladas (quando se usa métodos como << ou +=, a string pode ser alterada).

Objetos: Todos esses tipos primitivos são objetos em Ruby. Por exemplo, 42 é um objeto da classe Integer, e "Olá" é um objeto da classe String. Isso permite que você utilize métodos e funcionalidades de objetos para manipular esses tipos primitivos.

Conversão de Tipos: Ruby oferece métodos para converter entre diferentes tipos primitivos, como to_i, to_f, to_s, e to_sym. Por exemplo, "123".to_i converte a string "123" para o inteiro 123. Esses tipos primitivos são a base para a construção de expressões e estruturas de dados mais complexas em Ruby. Combinando-os, você pode criar variáveis, realizar cálculos, manipular texto e controlar o fluxo do seu programa.

- CONVERSÃO: 
.to_i converte para inteiro.
.to_f converte para float.
.to_s converte para string.

OPERADORES ARITMÉTICOS:
Adição (+)

Descrição: Soma dois números.
Exemplo: 5 + 3 resulta em 8.
Subtração (-)

Descrição: Subtrai o segundo número do primeiro.
Exemplo: 10 - 4 resulta em 6.
Multiplicação (*)

Descrição: Multiplica dois números.
Exemplo: 7 * 5 resulta em 35.
Divisão (/)

Descrição: Divide o primeiro número pelo segundo. Retorna um Float.
Exemplo: 10 / 4 resulta em 2.5.
Divisão Inteira (div)

Descrição: Divide o primeiro número pelo segundo e retorna o quociente inteiro.
Exemplo: 10.div(4) resulta em 2.
Módulo (%)

Descrição: Retorna o restante da divisão entre dois números.
Exemplo: 10 % 4 resulta em 2.
Potenciação (**)

Descrição: Eleva o primeiro número à potência do segundo.
Exemplo: 2 ** 3 resulta em 8.
Operadores Aritméticos Combinados
Adição Atribuição (+=)

Descrição: Adiciona e atribui o resultado à variável.
Exemplo: a += 3 é equivalente a a = a + 3.
Subtração Atribuição (-=)

Descrição: Subtrai e atribui o resultado à variável.
Exemplo: a -= 4 é equivalente a a = a - 4.
Multiplicação Atribuição (*=)

Descrição: Multiplica e atribui o resultado à variável.
Exemplo: a *= 5 é equivalente a a = a * 5.
Divisão Atribuição (/=)

Descrição: Divide e atribui o resultado à variável.
Exemplo: a /= 4 é equivalente a a = a / 4.
Módulo Atribuição (%=)

Descrição: Aplica o operador módulo e atribui o resultado à variável.
Exemplo: a %= 4 é equivalente a a = a % 4.
Potenciação Atribuição (**=)

Descrição: Eleva à potência e atribui o resultado à variável.
Exemplo: a **= 3 é equivalente a a = a ** 3.
Esses operadores são usados para realizar operações matemáticas básicas em Ruby e são bastante diretos para quem está familiarizado com operações aritméticas.

OPERADORES RELACIONAIS:
> maior
< menor
>= maior ou igual
<= menor ou igual
== igual
!= diferente

Operador spaceship <=>: m Ruby é conhecido como o operador "spaceship" ou operador de comparação, e é usado para realizar uma comparação entre dois valores. Este operador é bastante útil para determinar a ordem relativa entre dois elementos e é fundamental em muitas operações de ordenação e comparação.

Funcionamento do Operador <=>
O operador <=> retorna um valor inteiro que indica a relação entre os dois operandos:

Se o primeiro operando é menor que o segundo: Retorna -1.
Se o primeiro operando é igual ao segundo: Retorna 0.
Se o primeiro operando é maior que o segundo: Retorna 1.

EXEMPLO:
irb(main):019> 1 <=> 2
=> -1
irb(main):020> 2 <=> 2
=> 0
irb(main):021> 2 <=> 1
=> 1

OPERADORES DE ATRIBUIÇÃO:

Atribuição Simples (=): Atribui um valor à variável.
Atribuição Adicional (+=): Adiciona um valor à variável.
Atribuição Subtrativa (-=): Subtrai um valor da variável.
Atribuição Multiplicativa (*=): Multiplica a variável por um valor.
Atribuição Divisiva (/=): Divide a variável por um valor.
Atribuição de Módulo (%=): Calcula o módulo e atribui o resultado.
Atribuição de Potenciação (**=): Eleva a variável à potência de um valor.

OPERADORES DE INTERVALO: Servem para quando precisarmos ir de um número a outro.
No Ruby, os operadores de intervalo são usados para criar intervalos de valores. Eles são:
    .. (intervalo fechado): inclui o valor final. Exemplo: 1..5 representa os números de 1 a 5. (ou seja vai ate o ultimo elemento)
    ... (intervalo exclusivo): exclui o valor final. Exemplo: 1...5 representa os números de 1 a 4. (ou seja vai ate o penultimo elemento)

- ESTRUTURAS CONDICIONAIS: Em Ruby, estruturas condicionais são usadas para executar diferentes blocos de código dependendo de uma condição. Elas permitem que o programa tome decisões e siga diferentes caminhos de execução. Vamos explorar as principais estruturas condicionais do Ruby:

1. if
A estrutura básica de decisão. Executa um bloco de código se a condição for verdadeira.

if condição
  # código a ser executado se a condição for verdadeira
end
Exemplo:
idade = 18
if idade >= 18
  puts "Você é maior de idade."
end

2. else
Usado em conjunto com if. O bloco else é executado se a condição do if for falsa.
if condição
  # código se a condição for verdadeira
else
  # código se a condição for falsa
end
Exemplo:
idade = 16
if idade >= 18
  puts "Você é maior de idade."
else
  puts "Você é menor de idade."
end

3. elsif
Permite testar várias condições diferentes em sequência. Usado após um if e antes de um else.
if condição1
  # código se condição1 for verdadeira
elsif condição2
  # código se condição2 for verdadeira
else
  # código se nenhuma das condições anteriores for verdadeira
end
Exemplo:
nota = 85
if nota >= 90
  puts "Conceito A"
elsif nota >= 80
  puts "Conceito B"
elsif nota >= 70
  puts "Conceito C"
else
  puts "Conceito D"
end

4. case
Uma alternativa ao uso de múltiplos if...elsif. Avalia uma expressão e compara com várias possibilidades.
case expressão
when valor1
  # código se a expressão for igual a valor1
when valor2
  # código se a expressão for igual a valor2
else
  # código se nenhum dos valores anteriores corresponder
end
Exemplo:
dia_da_semana = "segunda-feira"
case dia_da_semana
when "segunda-feira"
  puts "Início da semana de trabalho."
when "sábado", "domingo"
  puts "Final de semana."
else
  puts "Dia útil."
end

5. unless
Executa um bloco de código se a condição for falsa. É o oposto de if.
unless condição
  # código a ser executado se a condição for falsa
end
Exemplo:
idade = 16
unless idade >= 18
  puts "Você é menor de idade."
end

6. ternário
Uma forma compacta de uma expressão if...else. É útil para atribuições rápidas.
condição ? valor_se_verdadeiro : valor_se_falso
Exemplo:
idade = 18
status = idade >= 18 ? "Maior de idade" : "Menor de idade"
puts status

7. if Modificado (Inline)
Permite executar uma expressão condicional de forma compacta.

# Código se a condição for verdadeira
puts "Você é maior de idade." if idade >= 18
8. unless Modificado (Inline)
Similar ao if modificado, mas para o caso de condição falsa.

# Código se a condição for falsa
puts "Você é menor de idade." unless idade >= 18
Essas estruturas fornecem flexibilidade para o controle de fluxo em Ruby, permitindo que o código reaja a diferentes condições de maneira eficiente.

- OPERADORES LÓGICOS:
&& and Funciona com 2 valores/condições
|| or Funciona com 2 valores/condições
! not Funicona apenas com 1 valor/condição

- ESTRUTURAS DE REPETIÇÃO:

WHILE: O loop while executa um bloco de código enquanto uma condição for verdadeira.
Sintaxe:
while condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5, e imprime os valores de i de 0 a 4.
i = 0
while i < 5
  puts i
  i += 1
end


UNTIL: O loop until é o oposto do while e executa um bloco de código enquanto a condição for falsa.
Sintaxe:
until condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5.
i = 0
until i >= 5
  puts i
  i += 1
end

-VETORES: vetores são conhecidos como arrays. Um array é uma coleção de elementos armazenados em uma única variável, permitindo o acesso e manipulação de dados de forma organizada. Aqui está uma explicação detalhada sobre como trabalhar com arrays em Ruby:

Criando Arrays
Você pode criar um array de várias maneiras:

# Criando um array vazio
empty_array = []

# Criando um array com alguns elementos
numbers = [1, 2, 3, 4, 5]
names = ["Alice", "Bob", "Charlie"]

# Criando um array com elementos de tipos diferentes
mixed_array = [1, "hello", 3.14, true]
Acessando Elementos
Os elementos em um array são acessados por índices, que começam em 0:

numbers = [10, 20, 30, 40, 50]
puts numbers[0]  # Saída: 10
puts numbers[2]  # Saída: 30
Você também pode usar índices negativos para acessar os elementos a partir do final do array:

puts numbers[-1]  # Saída: 50 (último elemento)
puts numbers[-2]  # Saída: 40 (penúltimo elemento)
Modificando Arrays
Você pode adicionar, remover e modificar elementos em um array:

# Adicionando elementos
numbers.push(60)        # Adiciona 60 ao final do array
numbers << 70           # Adiciona 70 ao final do array

# Removendo elementos
numbers.pop             # Remove o último elemento (70)
numbers.shift           # Remove o primeiro elemento (10)

# Modificando elementos
numbers[1] = 100        # Altera o segundo elemento para 100
Iterando Sobre Arrays
Você pode usar loops para iterar sobre os elementos de um array:

numbers = [1, 2, 3, 4, 5]

# Usando each para iterar
numbers.each do |number|
  puts number
end

# Usando um loop for
for number in numbers
  puts number
end
Métodos Comuns de Arrays
Aqui estão alguns métodos úteis para arrays em Ruby:

length ou size: Retorna o número de elementos no array.

puts numbers.length    # Saída: 5
puts numbers.size      # Saída: 5
include?: Verifica se um array contém um elemento específico.

puts numbers.include?(3)  # Saída: true
sort: Ordena os elementos do array.

sorted_numbers = numbers.sort
puts sorted_numbers       # Saída: [1, 2, 3, 4, 5]
map: Cria um novo array com os resultados de aplicar um bloco a cada elemento.

squared_numbers = numbers.map { |n| n * n }
puts squared_numbers       # Saída: [1, 4, 9, 16, 25]
select: Retorna um novo array contendo todos os elementos para os quais o bloco retorna verdadeiro.

even_numbers = numbers.select { |n| n.even? }
puts even_numbers          # Saída: [2, 4]
reject: Retorna um novo array contendo todos os elementos para os quais o bloco retorna falso.

odd_numbers = numbers.reject { |n| n.even? }
puts odd_numbers           # Saída: [1, 3, 5]
Conclusão
Arrays em Ruby são uma estrutura de dados fundamental que permite armazenar e manipular coleções de elementos de maneira eficiente. Você pode acessar, modificar e iterar sobre os elementos de arrays usando uma variedade de métodos e técnicas, o que facilita o trabalho com listas de dados em seus programas Ruby.

nome_do_array.push(valor) - Adiciona um valor na próxima posição do array.
nome_do_array.delete(valor) - Remove o valor especificado.
nome_do_vetor[posição]- Para ver o valor de uma determinada posição.

- HASHES: são uma estrutura de dados que armazena pares de chave-valor, onde cada chave é única e associada a um valor. Hashes são úteis para armazenar e acessar dados de forma eficiente. Eles são semelhantes a dicionários em outras linguagens de programação.

Criando Hashes
Você pode criar um hash de várias maneiras:

# Criando um hash vazio
empty_hash = {}

# Criando um hash com pares de chave-valor
person = {
  "name" => "Alice",
  "age" => 30,
  "city" => "New York"
}

# Usando símbolos como chaves (uma prática comum)
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}
Acessando e Modificando Valores
Para acessar ou modificar valores em um hash, você usa a chave correspondente:

person = { name: "Alice", age: 30, city: "New York" }

# Acessando um valor
puts person[:name]  # Saída: Alice

# Modificando um valor
person[:age] = 31
puts person[:age]   # Saída: 31

# Adicionando um novo par chave-valor
person[:occupation] = "Engineer"
puts person[:occupation]  # Saída: Engineer
Métodos Comuns de Hashes
Aqui estão alguns métodos úteis para trabalhar com hashes em Ruby:

keys: Retorna um array com todas as chaves do hash.

puts person.keys.inspect  # Saída: [:name, :age, :city, :occupation]
values: Retorna um array com todos os valores do hash.

puts person.values.inspect  # Saída: ["Alice", 31, "New York", "Engineer"]
each: Itera sobre cada par chave-valor no hash.

person.each do |key, value|
  puts "#{key}: #{value}"
end
# Saída:
# name: Alice
# age: 31
# city: New York
# occupation: Engineer
has_key?: Verifica se o hash contém uma chave específica.

puts person.has_key?(:age)  # Saída: true
puts person.has_key?(:salary)  # Saída: false
has_value?: Verifica se o hash contém um valor específico.

puts person.has_value?("Alice")  # Saída: true
puts person.has_value?(25)       # Saída: false
delete: Remove um par chave-valor do hash.

person.delete(:occupation)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"New York"}
merge: Mescla dois hashes, com o segundo hash sobrescrevendo valores do primeiro hash para chaves iguais.

new_info = { city: "San Francisco", email: "alice@example.com" }
person.merge!(new_info)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"San Francisco", :email=>"alice@example.com"}
Hashes e Símbolos
Usar símbolos como chaves é uma prática comum em Ruby, pois os símbolos são mais eficientes em termos de desempenho e memória comparados às strings:

# Usando símbolos como chaves
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}

# Acessando valores
puts person[:name]  # Saída: Alice
Hashes Aninhados
Você pode ter hashes dentro de hashes para representar estruturas de dados mais complexas:

people = {
  alice: { age: 30, city: "New York" },
  bob: { age: 25, city: "San Francisco" }
}
puts people[:alice][:city]  # Saída: New York

Conclusão
Hashes são uma ferramenta poderosa em Ruby para armazenar e organizar dados de forma eficiente. Eles permitem o acesso rápido a valores baseados em chaves e oferecem uma variedade de métodos para manipular e consultar os dados armazenados.

PRIMEIRA FORMA:
- criando um hash: h = { "a" => "123", "b" => "456" } 
- Acessando o valor de uma chave: h["a"].

SEGUNDA FORMA:
 - criando um hash: h = { a: "123", b: "456" }
 - Acessando o valor de uma chave: h[:a].

SÍMBOLOS: Definição 1: (São strings estáticas) 
Definição 2: Símbolos são objetos imutáveis e únicos que representam identificadores, nomes ou valores constantes. Usamos para criar hashes.

Sintaxe: Criados prefixando um nome com dois pontos (:), como :name, :age, :city.

Características:

Imutabilidade: Não podem ser alterados após a criação.
Identidade Única: Cada símbolo com o mesmo nome é o mesmo objeto na memória.
Eficiência: Comparações e armazenamento são mais eficientes do que para strings.
Usos Comuns:
Chaves de Hashes: Usados como chaves em hashes por sua eficiência.

person = { name: "Alice", age: 30, city: "New York" }
Parâmetros de Métodos: Representam opções ou parâmetros de métodos.

def greet(options = {})
  name = options[:name] || "Guest"
  puts "Hello, #{name}!"
end
Identificadores: Representam eventos ou mensagens.

event = :login_success
Comparação com Strings:

Imutabilidade: Strings podem ser alteradas, símbolos não.
Eficiência: Comparações e armazenamento são mais rápidos e econômicos para símbolos.
Exemplo de Comparação

# Comparando símbolos
symbol1 = :hello
symbol2 = :hello
puts symbol1.equal?(symbol2)  # Saída: true (mesmo objeto na memória)
Símbolos são ideais para representar valores constantes e identificadores devido à sua imutabilidade e eficiência.

.object_id - Retorna o endereço de memória de uma variável. EX: "Lucas".object_id -> Isso na primeira vez que foi executado retorna 13660, na segunda retornou 15500, ou seja o endereço sempre muda. Obs: se usarmos esse método com um símbolo, o endereço de memórianão muda.
Ex:
irb(main):009> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez.
irb(main):010> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez. 


-ITERADOR EACH (mais usado no ruby do que o for): é uma maneira simples e poderosa de percorrer elementos de coleções, como arrays e hashes, e realizar uma operação para cada elemento.

Como Funciona
Para Arrays: O método each passa cada elemento do array para um bloco de código.

array = [1, 2, 3]
array.each do |element|
  puts element
end
Saída:
1
2
3

Explicação: O bloco (do |element| ... end) é executado para cada elemento do array, e element representa o item atual do array.

Para Hashes: O método each passa cada par chave-valor do hash para um bloco de código.

hash = { a: 1, b: 2, c: 3 }
hash.each do |key, value|
  puts "#{key}: #{value}"
end
Saída:

makefile
Copiar código
a: 1
b: 2
c: 3
Explicação: O bloco (do |key, value| ... end) é executado para cada par chave-valor do hash, onde key é a chave e value é o valor correspondente.

Resumo
each é usado para iterar sobre todos os elementos de uma coleção.
Array: Passa cada elemento para o bloco.
Hash: Passa cada par chave-valor para o bloco.
Uso: Ideal para aplicar uma operação a cada item sem modificar a coleção original.

MEU EXEMPLO: Esse código pega a que é o elemento do array, passe em cada um deles, e quando for passar em cada um deles chame de element e depois imprima-o na tela.

PRIMEIRA FORMA INLINE:
a = [1,4,6,89,0]
a.each { |element| puts element } 

SEGUNDA FORMA:
a.each do |el|
   puts el
   puts el * 2
   puts el * 3
 end

-REPETIÇÕES FIXAS COM TIMES: Em Ruby, "repetições fixas com times" se refere ao uso do método times para executar um bloco de código um número fixo de vezes.

Aqui está um resumo de como funciona:

O método times é chamado em um número inteiro.
Esse método executa o bloco de código associado ao número de vezes especificado.
O bloco de código recebe o índice da iteração como um argumento, começando de 0 até n-1, onde n é o número especificado.
Exemplo básico:

# EXEMPLO DE COM SINTAXE PARA MULTIPLAS LINHAS
5.times do |i|
  puts "Iteração número #{i}"
end
Saída:

Iteração número 0
Iteração número 1
Iteração número 2
Iteração número 3
Iteração número 4
Neste exemplo, o bloco de código é executado 5 vezes, e o índice da iteração é passado como i, começando de 0 e indo até 4.
O times é útil para repetição simples e quando você precisa de um número fixo de iterações.

# EXEMPLOS COM SINTAXE PARA UMA LINHA ↓↓↓
OUTRO EXEMPLO SEM VARIÁVEL CONTADORA: 

# O método `times` é chamado no número 5.
# Isso significa que o bloco de código será executado 5 vezes.
5.times { puts "Lucas" }  # Em cada iteração, imprime a string "Lucas" no console

# Saída esperada:
# Lucas
# Lucas
# Lucas
# Lucas
# Lucas
#
# O método `times` executa o bloco o número de vezes especificado, 
# que neste caso é 5.

OUTRO EXEMPLO COM VARIÁVEL CONTADORA:

# O método `times` é chamado no número 5.
# O bloco de código será executado 5 vezes.
# A cada iteração, o índice da iteração é passado como variável `x`.

5.times do |x| 
  puts "#{x} - Lucas"  # Imprime o índice da iteração seguido por " - Lucas"
end

# Saída esperada:
# 0 - Lucas
# 1 - Lucas
# 2 - Lucas
# 3 - Lucas
# 4 - Lucas
#
# O método `times` executa o bloco o número de vezes especificado (5 vezes).
# A variável `x` representa o índice da iteração, começando de 0 e indo até 4.

Ou seja, executa um código numa quantidade determinada de vezes.  Nesse caso 5 vezes(5.times)

______________________________________________________________________________________________

ORIENTAÇÃO A OBJETOS: É  um paradigma para o desenvolvimento de software que baseia-se na utilização de componentes individuais (objetos) que colaboram para construir sistemas mais complexos. A colaboração entre os objetos é feita através do envio de mensagens(requisição de serviços). O paradigma de objetos baseia-se em alguns conceitos como: 
- Classes
- Objetos
- Encapsulamento
- Herança
- Polimorfismo 
- Entre outros.

FUNDAMENTOS: 
- Qualquer coisa é um objeto
- Objetos realizam tarefas através da requisição de serviços a outros objetos.
- Cada objeto pertence a uma determinada classe. Uma classe agrupa objetos similares.
- A classe é um repositório para comportamento associado ao objeto.
- Classes são organizadas em hierarquias.

PILARES:
- Abstração: Imaginar o objeto que tenham - Identidade única(ex nome), Atributos(características), Métodos(ações).
- Encapsulamento: Esconder as propriedades dos objetos para obter mais segurança.
- Herança: Permite o reúso de código.
- Polimorfismo: É a capacidade de referenciar um objeto de várias formas diferentes.

CLASSE: Uma classe é um gabarito para a definição de objetos. Através da definição de uma classe, descreve-se que propriedades/atributos e métodos/ações o objeto terá.
Em resumo uma classe representa um conjunto de objetos com características afins. Uma classe define o comportamento dos objetos através de seus métodos, e quais estados ele é capaz de manter através de seus atributos.

A partir da classe(forma/gabarito) eu posso gerar varios objetos "iguais". Quando eu gero esses objetos iguais, a única coisa que vai mudar entre eles é: quais atributos cada um vai ter, e quais são os métodos que els vão poder executar.

É possível especificar classes para entidades físicas, conceituais ou de software. EX:
- Entidade física: caminhão, carro, bicicleta, etc.
- Entidade Conceitual: processo químico, matrícula, etc.
- Entidade de Software: lista encadeada, arquivo, etc.

EXEMPLO: Uma classe lâmpada pode conter os atributos "potencia" e "voltagem", que são características comuns à todas as lâmpadas , e pode conter as ações "ligar" e "desligar", que também são características comuns.

Uma classe em programação é como um modelo que define as características e ações de seus objetos. Por exemplo, se criarmos uma classe chamada Pessoa, podemos gerar um objeto específico, como Lucas. Esse objeto tem atributos como nome, que será "Lucas", e pode ter outros atributos, como a cor dos olhos. Além disso, o objeto pode realizar ações definidas pela classe, como pular ou andar. Todos os objetos criados a partir dessa classe terão as mesmas características e ações básicas definidas no modelo da classe.

- Encapsulamento: Se refere a esconder os dados (atributos) dentro do objeto. Produz duas visões do obejto:
* Visão Interna(COMO o obejto faz).
* Visão Externa(O QUE o objeto faz).

Em se tratando de classes, o encapsulado é obtido através da vidibilidade, conhecida tambem como "modificadores de acesso". Os modificadores de acessos mais comuns são:

- public/público: Representado por um sinal de "+" na notaçãi UML. Elementos declarados como público podem ser acessados a partir de qualqueroutra classe.
- private/privado: Representado por um sinal de "-" na notação UML. Elementos private só podem ser acessados pela própria classe.
- protected/protegido: Representado por um sinal de sustenido "#" na notação UML. Elementos protected só podem ser acessados pela própria classe e por suas descendentes.

-EXEMPLO DE ENCAPSULAMENTO: O funcionamento interno de um telefone é escondido(ou encapsulado)do usuário. Para o usuário realizar uma chamada telefônica(visão externa) ele não precisa conhecer os detalhes da eletrônica utilizados no teelfone(visão interna).

-OBJETO: Classes são fábricas de objetos. Objetos são instâncias de uma classe, ou seja vieram de uma classe.
- INSTÂNCIA: uma instância é um objeto criado a partir de uma classe em programação orientada a objetos.

* Um objeto é capaz de armazenar estadOs através de seus atributos e reagir a mensagens enviadas a ele, assim como se relacionar e enviar mensagens a outros objetos.
* Um objeto é qualquer indivíduo, lugar, evento, coisa, tela, relatório ou conceito que seja aplicável ao sistema.
* Todo objeto pertence a uma determinada classe e possui atributos próprios.
* Os atributos são mutáveis e podem receber diferentes valores de acordo com as características do obejto.

A criação de um objeto consiste em sua instanciação, segundo, " cada instância tem seus próprios valores de atributos, mas compartilha o nome e os comportamentos dos atributos com as outras instâncias da classe.

Para definir uma classe, podemos tomar por base o Diagrama de Classe criado na última aula:

+--------------------------------+
|             Conta               |
+--------------------------------+
| - saldo: float                  |
| - numero: String                |
+--------------------------------+
| + debitar()                     |
| + creditar()                    |
| + transferir()                  |
| + consultarSaldo()              |
+--------------------------------+

Em ruby definimos uma classe da seguinte forma:
class Conta
  corpoDaClasse (atributos e métodos)
end

- Convenções a serem usadas: O nome da classe inicia-se com letra maiúscula e pára nomes compostos devemos usar o padrão CamelCase. Ex: NomeDaMinhaClasse.
O corpo de uma classe deve conter: Atributos, Metodos,  Construtor(método de inicialização).
Instanciando uma classe: 
* obj1 = Classe.new


Instanciando uma classe no irb:
PS C:\Users\lucas\OneDrive\Área de Trabalho\Curso-de-Ruby-OOP> irb
irb(main):001> require_relative "09-definindo_classes" 
=> true
irb(main):002> obj1 = Conta.new
=> #<Conta:0x000001acc8c622a0>
irb(main):003> obj1
=> #<Conta:0x000001acc8c622a0>
irb(main):004> obj1.class
=> Conta

Em ruy definimos um método da seguinte forma:
class Pessoa
  def gritar
    #corpo do método
  end
end

- Convenções a serem usadas: O nome do método inicia-se com letra minúscula e para nomes compostos devemos usar o padrão snake_case. EX: nome_do_meu_metodo.

- Métodos com parâmetros: 
def gritar(texto)
  puts texto
end

- Retorno do método:
def gritar(texto)
  return texto
end

Definindo Atributos

Variáveis de instância:

Variáveis de instância armazenam valores específicos para cada objeto em Ruby. Isso significa que cada instância de uma classe pode ter seus próprios valores distintos para essas variáveis. Em Ruby, essas variáveis são precedidas por um símbolo de arroba (@).

Por exemplo:

ruby
Copiar código
class Pessoa
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end

  def mostrar_informacoes
    puts "Nome: #{@nome}, Idade: #{@idade}"
  end
end

pessoa1 = Pessoa.new("Alice", 30)
pessoa2 = Pessoa.new("Bob", 25)

pessoa1.mostrar_informacoes  # Saída: Nome: Alice, Idade: 30
pessoa2.mostrar_informacoes  # Saída: Nome: Bob, Idade: 25
Neste exemplo, @nome e @idade são variáveis de instância. Cada objeto pessoa1 e pessoa2 tem seus próprios valores para essas variáveis, que são distintos e específicos para cada instância da classe Pessoa. Isso permite que cada objeto mantenha e gerencie seu próprio estado de maneira independente.
___________________________________________________________________________________________________________________

EXEMPLO DE EXPLICAÇÃO(MINHA) DO PROCESSO DE CRIAR E USAR UMA CLASSE EM RUBY : entao basicamente primeiro crio uma classe e inicializo as variáveis de instancia dentro do método initialize, depois crio os métodos que a classe ira realizar utilizando as variáveis de instancia.  Depois instancio os objetos passando os valores dos parâmetros e por ultimo mostro os valores dos objetos na tela.

___________________________________________________________________________________________________________________

GET - Pegar.
SET- Guardar.

- ACESSORES: No Ruby, acessores são métodos que permitem o acesso e a modificação dos atributos de uma classe. Eles são uma maneira conveniente de gerenciar o acesso a variáveis de instância e encapsular a lógica de leitura e escrita desses atributos.
Tipos de Acessores

    Leitura e Escrita Simples
        Leitura (attr_reader): Cria um método de leitura para uma variável de instância, permitindo que você acesse o valor dessa variável de fora da classe, mas não o modifique diretamente.
        Escrita (attr_writer): Cria um método de escrita para uma variável de instância, permitindo que você modifique o valor dessa variável de fora da classe, mas não leia o valor diretamente.
        Leitura e Escrita (attr_accessor): Cria métodos de leitura e escrita para uma variável de instância, permitindo tanto a leitura quanto a modificação do valor da variável de fora da classe.

    Métodos de Acesso Personalizados
        Além dos acessores automáticos, você pode definir métodos de acesso e modificação personalizados para adicionar lógica adicional ao acessar ou alterar os valores das variáveis de instância.

Exemplo de Uso

Aqui está um exemplo de como usar os acessores no Ruby:

ruby

class Pessoa
  # Definindo atributos de instância com acessores
  attr_accessor :nome, :idade

  # Método initialize para inicializar os atributos
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end
end

# Criando uma nova instância da classe Pessoa
pessoa = Pessoa.new("Lucas", 27)

# Usando os métodos de leitura e escrita criados automaticamente
puts pessoa.nome  # Saída: Lucas
puts pessoa.idade # Saída: 27

# Modificando os valores dos atributos
pessoa.nome = "Wendel"
pessoa.idade = 49

# Usando os métodos de leitura após modificação
puts pessoa.nome  # Saída: Wendel
puts pessoa.idade # Saída: 49

Explicação dos Acessores

    attr_reader
        Uso: attr_reader :nome
        O que faz: Cria um método chamado nome que retorna o valor da variável de instância @nome. Não cria um método para definir o valor de @nome.

    ruby

class Pessoa
  attr_reader :nome

  def initialize(nome)
    @nome = nome
  end
end

attr_writer

    Uso: attr_writer :nome
    O que faz: Cria um método chamado nome= que define o valor da variável de instância @nome. Não cria um método para ler o valor de @nome.

ruby

class Pessoa
  attr_writer :nome

  def initialize(nome)
    @nome = nome
  end
end

attr_accessor

    Uso: attr_accessor :nome
    O que faz: Cria tanto o método nome para leitura quanto o método nome= para escrita. Isso permite acessar e modificar a variável de instância @nome.

ruby

    class Pessoa
      attr_accessor :nome

      def initialize(nome)
        @nome = nome
      end
    end

Métodos de Acesso Personalizados

Se você precisar de lógica personalizada ao acessar ou modificar atributos, você pode definir métodos de acesso manualmente:

ruby

class Pessoa
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end

  def nome
    @nome
  end

  def nome=(novo_nome)
    @nome = novo_nome.upcase # Exemplo de lógica personalizada
  end

  def idade
    @idade
  end

  def idade=(nova_idade)
    @idade = nova_idade
  end
end

pessoa = Pessoa.new("Lucas", 27)
puts pessoa.nome         # Saída: LUCAS (nome convertido para maiúsculas)

Conclusão

Acessores no Ruby são uma maneira poderosa e concisa de gerenciar o acesso a variáveis de instância. Usando attr_reader, attr_writer, e attr_accessor, você pode rapidamente criar métodos para acessar e modificar atributos, enquanto métodos personalizados oferecem flexibilidade para adicionar lógica adicional ao acesso e modificação dos dados.


-MÉTODOS CONSTRUTORES OU MÉTODOS DE INICIALIZAÇÃO: SINTAXE:

class Pessoa
    def initialize(nome)
    @var_nome = nome
  end
end

Permitem inicializar um objeto com dados "padrão". É invocado automaticamente quando instanciamos e criamos um objeto, assim preenchendo os atributos. É possível passar quantos parâmetros voce quiser.


-HERANÇA ENTRE CLASSES: Conceito: Herança permite que uma classe (subclasse) herde métodos e atributos de outra classe (superclasse), facilitando a reutilização e organização do código.

Sintaxe Básica: Use < para definir que uma classe herda de outra.

ClasseFilha < ClassePai ou pode ser chamada de SubClass < SuperClass

- METHOD OVERRIDING: Sobrescrever métodos da classe pai. Sobrescrita de métodos é um conceito em programação orientada a objetos onde uma subclasse fornece uma implementação específica para um método que já foi definido na sua superclasse. Isso permite que a subclasse altere o comportamento do método herdado para atender às suas necessidades específicas.
Como o Overriding é Usado no Código:

    Classe Base (Calculadora): Define um método somar que retorna a soma simples de dois números. Esta é a implementação padrão.

    Subclasse (CalculadoraFashion): Herda da classe Calculadora e sobrescreve o método somar. Em vez de apenas retornar a soma dos números, a nova implementação fornece uma string formatada que inclui a soma. Isso é feito para alterar o comportamento do método somar na subclasse para algo mais específico e descritivo.
        Antes da Sobrescrita: O método somar na Calculadora simplesmente retorna o resultado da adição.
        Após a Sobrescrita: O método somar na CalculadoraFashion retorna uma mensagem personalizada, que inclui o resultado da adição.

BENEFÍCIOS DO OVERRIDING: Personalização: Permite que subclasses personalizem ou modifiquem o comportamento de métodos herdados sem alterar a implementação da classe base.
    Polimorfismo: Facilita o polimorfismo, onde o método chamado é determinado pelo tipo da instância do objeto em tempo de execução, permitindo que diferentes comportamentos sejam executados dependendo da classe do objeto.Em Resumo: No código fornecido, a sobrescrita de métodos é usada para alterar o comportamento do método somar quando chamado a partir de uma instância da CalculadoraFashion. Isso demonstra como você pode modificar ou estender a funcionalidade de uma classe base, oferecendo uma versão específica do método para a subclasse.

- SUPER: Em Ruby, a palavra-chave super é utilizada dentro de um método para chamar o método correspondente da classe pai (ou superclasse). Isso é útil quando você está sobrescrevendo um método em uma subclasse e deseja adicionar ou modificar o comportamento do método da classe pai.O super serve basicamente para  invocar o método correspondente na classe pai.    




