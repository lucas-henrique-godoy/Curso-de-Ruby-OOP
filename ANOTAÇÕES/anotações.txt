CURSO DE RUBY
- Verificar o tipo do número usando o método class. Exemplo1- 23.class retona Interger. Exemplo2- 3.5.class retorna float.

- COMENTARIO DE 1 LINHA: #
- COMENTARIO DE VARIAS LINHAS: =begin codigo =end
- INTERPOLAÇÃO DE VARIÁVEIS: #{variavel}. Pra funcionar deve-se usar aspas duplas.

- GETS
O método gets é usado para ler uma linha de entrada do usuário. Quando você usa gets, o programa espera que o usuário digite algo e pressione Enter. O texto digitado pelo usuário é então retornado como uma string.

Exemplo:
print "Digite seu nome: "
nome = gets
puts "Olá, #{nome}!"

Se o usuário digitar "Ana" e pressionar Enter, o programa exibirá "Olá, Ana!" com um caractere de nova linha ao final da string "Ana".

- .CHOMP
O método .chomp é usado para remover o caractere de nova linha (\n) do final de uma string. Quando você usa gets, a string retornada inclui o caractere de nova linha no final, porque o Enter digitado pelo usuário é considerado parte da entrada. O método .chomp remove esse caractere.

Exemplo:
print "Digite seu nome: "
nome = gets.chomp
puts "Olá, #{nome}!"

Neste caso, se o usuário digitar "Ana" e pressionar Enter, a variável nome conterá "Ana" sem o caractere de nova linha no final, e o programa exibirá "Olá, Ana!" de forma mais limpa.
Resumindo
gets: Lê uma linha de entrada do usuário e inclui o caractere de nova linha.
.chomp: Remove o caractere de nova linha do final de uma string.
Você pode usar .chomp sempre que quiser processar a entrada do usuário sem a quebra de linha final, tornando o tratamento de strings mais simples e direto.

- .inspect= Ajuda a obter uma visão clara e detalhada de como os dados estão estruturados dentro de um objeto. Ex: como o método puts sempre gera umaquebra de linha, o .inspect mostra o \n na saida de uma variavel.

- TIPOS PRIMITIVOS: os tipos primitivos são as categorias básicas de dados que a linguagem oferece para representar valores e realizar operações. Embora Ruby seja uma linguagem orientada a objetos, onde tudo é um objeto, os tipos primitivos ainda são fundamentais para a programação. Aqui estão os principais tipos primitivos em Ruby:

Inteiros (Integer): Representam números inteiros, tanto positivos quanto negativos.
Exemplo: 42, -7

Números de ponto flutuante (Float): Representam números que possuem uma parte decimal.
Exemplo: 3.14, -0.001
Strings (String):

Representam sequências de caracteres.
Exemplo: "Olá, mundo!", 'Ruby'
Strings podem ser definidas usando aspas duplas (") ou aspas simples ('). Aspas duplas permitem interpolação de variáveis e escape de caracteres, enquanto aspas simples não.
Booleanos (TrueClass e FalseClass):

Representam valores lógicos: verdadeiro (true) e falso (false).
Exemplo: true, false
Em Ruby, qualquer valor que não seja false ou nil é considerado verdadeiro (truthy).
Nil (NilClass):

Representa a ausência de valor ou um valor nulo.
Exemplo: nil
É o único valor da classe NilClass e é usado para representar "nenhum valor" ou "nada".
Símbolos (Symbol):

Representam identificadores imutáveis e frequentemente utilizados como chaves em hashes ou para representar nomes e identificadores.
Exemplo: :nome, :idade
Características Importantes:
Imutabilidade: Em Ruby, alguns tipos primitivos são imutáveis. Por exemplo, strings podem ser mutáveis ou imutáveis dependendo de como são manipuladas (quando se usa métodos como << ou +=, a string pode ser alterada).

Objetos: Todos esses tipos primitivos são objetos em Ruby. Por exemplo, 42 é um objeto da classe Integer, e "Olá" é um objeto da classe String. Isso permite que você utilize métodos e funcionalidades de objetos para manipular esses tipos primitivos.

Conversão de Tipos: Ruby oferece métodos para converter entre diferentes tipos primitivos, como to_i, to_f, to_s, e to_sym. Por exemplo, "123".to_i converte a string "123" para o inteiro 123. Esses tipos primitivos são a base para a construção de expressões e estruturas de dados mais complexas em Ruby. Combinando-os, você pode criar variáveis, realizar cálculos, manipular texto e controlar o fluxo do seu programa.

- CONVERSÃO: 
.to_i converte para inteiro.
.to_f converte para float.
.to_s converte para string.

OPERADORES ARITMÉTICOS:
Adição (+)

Descrição: Soma dois números.
Exemplo: 5 + 3 resulta em 8.
Subtração (-)

Descrição: Subtrai o segundo número do primeiro.
Exemplo: 10 - 4 resulta em 6.
Multiplicação (*)

Descrição: Multiplica dois números.
Exemplo: 7 * 5 resulta em 35.
Divisão (/)

Descrição: Divide o primeiro número pelo segundo. Retorna um Float.
Exemplo: 10 / 4 resulta em 2.5.
Divisão Inteira (div)

Descrição: Divide o primeiro número pelo segundo e retorna o quociente inteiro.
Exemplo: 10.div(4) resulta em 2.
Módulo (%)

Descrição: Retorna o restante da divisão entre dois números.
Exemplo: 10 % 4 resulta em 2.
Potenciação (**)

Descrição: Eleva o primeiro número à potência do segundo.
Exemplo: 2 ** 3 resulta em 8.
Operadores Aritméticos Combinados
Adição Atribuição (+=)

Descrição: Adiciona e atribui o resultado à variável.
Exemplo: a += 3 é equivalente a a = a + 3.
Subtração Atribuição (-=)

Descrição: Subtrai e atribui o resultado à variável.
Exemplo: a -= 4 é equivalente a a = a - 4.
Multiplicação Atribuição (*=)

Descrição: Multiplica e atribui o resultado à variável.
Exemplo: a *= 5 é equivalente a a = a * 5.
Divisão Atribuição (/=)

Descrição: Divide e atribui o resultado à variável.
Exemplo: a /= 4 é equivalente a a = a / 4.
Módulo Atribuição (%=)

Descrição: Aplica o operador módulo e atribui o resultado à variável.
Exemplo: a %= 4 é equivalente a a = a % 4.
Potenciação Atribuição (**=)

Descrição: Eleva à potência e atribui o resultado à variável.
Exemplo: a **= 3 é equivalente a a = a ** 3.
Esses operadores são usados para realizar operações matemáticas básicas em Ruby e são bastante diretos para quem está familiarizado com operações aritméticas.

OPERADORES RELACIONAIS:
> maior
< menor
>= maior ou igual
<= menor ou igual
== igual
!= diferente

Operador spaceship <=>: m Ruby é conhecido como o operador "spaceship" ou operador de comparação, e é usado para realizar uma comparação entre dois valores. Este operador é bastante útil para determinar a ordem relativa entre dois elementos e é fundamental em muitas operações de ordenação e comparação.

Funcionamento do Operador <=>
O operador <=> retorna um valor inteiro que indica a relação entre os dois operandos:

Se o primeiro operando é menor que o segundo: Retorna -1.
Se o primeiro operando é igual ao segundo: Retorna 0.
Se o primeiro operando é maior que o segundo: Retorna 1.

EXEMPLO:
irb(main):019> 1 <=> 2
=> -1
irb(main):020> 2 <=> 2
=> 0
irb(main):021> 2 <=> 1
=> 1

OPERADORES DE ATRIBUIÇÃO:

Atribuição Simples (=): Atribui um valor à variável.
Atribuição Adicional (+=): Adiciona um valor à variável.
Atribuição Subtrativa (-=): Subtrai um valor da variável.
Atribuição Multiplicativa (*=): Multiplica a variável por um valor.
Atribuição Divisiva (/=): Divide a variável por um valor.
Atribuição de Módulo (%=): Calcula o módulo e atribui o resultado.
Atribuição de Potenciação (**=): Eleva a variável à potência de um valor.

- ESTRUTURAS CONDICIONAIS: Em Ruby, estruturas condicionais são usadas para executar diferentes blocos de código dependendo de uma condição. Elas permitem que o programa tome decisões e siga diferentes caminhos de execução. Vamos explorar as principais estruturas condicionais do Ruby:

1. if
A estrutura básica de decisão. Executa um bloco de código se a condição for verdadeira.

if condição
  # código a ser executado se a condição for verdadeira
end
Exemplo:
idade = 18
if idade >= 18
  puts "Você é maior de idade."
end

2. else
Usado em conjunto com if. O bloco else é executado se a condição do if for falsa.
if condição
  # código se a condição for verdadeira
else
  # código se a condição for falsa
end
Exemplo:
idade = 16
if idade >= 18
  puts "Você é maior de idade."
else
  puts "Você é menor de idade."
end

3. elsif
Permite testar várias condições diferentes em sequência. Usado após um if e antes de um else.
if condição1
  # código se condição1 for verdadeira
elsif condição2
  # código se condição2 for verdadeira
else
  # código se nenhuma das condições anteriores for verdadeira
end
Exemplo:
nota = 85
if nota >= 90
  puts "Conceito A"
elsif nota >= 80
  puts "Conceito B"
elsif nota >= 70
  puts "Conceito C"
else
  puts "Conceito D"
end

4. case
Uma alternativa ao uso de múltiplos if...elsif. Avalia uma expressão e compara com várias possibilidades.
case expressão
when valor1
  # código se a expressão for igual a valor1
when valor2
  # código se a expressão for igual a valor2
else
  # código se nenhum dos valores anteriores corresponder
end
Exemplo:
dia_da_semana = "segunda-feira"
case dia_da_semana
when "segunda-feira"
  puts "Início da semana de trabalho."
when "sábado", "domingo"
  puts "Final de semana."
else
  puts "Dia útil."
end

5. unless
Executa um bloco de código se a condição for falsa. É o oposto de if.
unless condição
  # código a ser executado se a condição for falsa
end
Exemplo:
idade = 16
unless idade >= 18
  puts "Você é menor de idade."
end

6. ternário
Uma forma compacta de uma expressão if...else. É útil para atribuições rápidas.
condição ? valor_se_verdadeiro : valor_se_falso
Exemplo:
idade = 18
status = idade >= 18 ? "Maior de idade" : "Menor de idade"
puts status

7. if Modificado (Inline)
Permite executar uma expressão condicional de forma compacta.

# Código se a condição for verdadeira
puts "Você é maior de idade." if idade >= 18
8. unless Modificado (Inline)
Similar ao if modificado, mas para o caso de condição falsa.

# Código se a condição for falsa
puts "Você é menor de idade." unless idade >= 18
Essas estruturas fornecem flexibilidade para o controle de fluxo em Ruby, permitindo que o código reaja a diferentes condições de maneira eficiente.

- OPERADORES LÓGICOS:
&& and Funciona com 2 valores/condições
|| or Funciona com 2 valores/condições
! not Funicona apenas com 1 valor/condição

- ESTRUTURAS DE REPETIÇÃO:

WHILE: O loop while executa um bloco de código enquanto uma condição for verdadeira.
Sintaxe:
while condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5, e imprime os valores de i de 0 a 4.
i = 0
while i < 5
  puts i
  i += 1
end


UNTIL: O loop until é o oposto do while e executa um bloco de código enquanto a condição for falsa.
Sintaxe:
until condição
  # código a ser executado
end
Exemplo: Neste exemplo, o loop continua enquanto i for menor que 5.
i = 0
until i >= 5
  puts i
  i += 1
end

-VETORES: vetores são conhecidos como arrays. Um array é uma coleção de elementos armazenados em uma única variável, permitindo o acesso e manipulação de dados de forma organizada. Aqui está uma explicação detalhada sobre como trabalhar com arrays em Ruby:

Criando Arrays
Você pode criar um array de várias maneiras:

# Criando um array vazio
empty_array = []

# Criando um array com alguns elementos
numbers = [1, 2, 3, 4, 5]
names = ["Alice", "Bob", "Charlie"]

# Criando um array com elementos de tipos diferentes
mixed_array = [1, "hello", 3.14, true]
Acessando Elementos
Os elementos em um array são acessados por índices, que começam em 0:

numbers = [10, 20, 30, 40, 50]
puts numbers[0]  # Saída: 10
puts numbers[2]  # Saída: 30
Você também pode usar índices negativos para acessar os elementos a partir do final do array:

puts numbers[-1]  # Saída: 50 (último elemento)
puts numbers[-2]  # Saída: 40 (penúltimo elemento)
Modificando Arrays
Você pode adicionar, remover e modificar elementos em um array:

# Adicionando elementos
numbers.push(60)        # Adiciona 60 ao final do array
numbers << 70           # Adiciona 70 ao final do array

# Removendo elementos
numbers.pop             # Remove o último elemento (70)
numbers.shift           # Remove o primeiro elemento (10)

# Modificando elementos
numbers[1] = 100        # Altera o segundo elemento para 100
Iterando Sobre Arrays
Você pode usar loops para iterar sobre os elementos de um array:

numbers = [1, 2, 3, 4, 5]

# Usando each para iterar
numbers.each do |number|
  puts number
end

# Usando um loop for
for number in numbers
  puts number
end
Métodos Comuns de Arrays
Aqui estão alguns métodos úteis para arrays em Ruby:

length ou size: Retorna o número de elementos no array.

puts numbers.length    # Saída: 5
puts numbers.size      # Saída: 5
include?: Verifica se um array contém um elemento específico.

puts numbers.include?(3)  # Saída: true
sort: Ordena os elementos do array.

sorted_numbers = numbers.sort
puts sorted_numbers       # Saída: [1, 2, 3, 4, 5]
map: Cria um novo array com os resultados de aplicar um bloco a cada elemento.

squared_numbers = numbers.map { |n| n * n }
puts squared_numbers       # Saída: [1, 4, 9, 16, 25]
select: Retorna um novo array contendo todos os elementos para os quais o bloco retorna verdadeiro.

even_numbers = numbers.select { |n| n.even? }
puts even_numbers          # Saída: [2, 4]
reject: Retorna um novo array contendo todos os elementos para os quais o bloco retorna falso.

odd_numbers = numbers.reject { |n| n.even? }
puts odd_numbers           # Saída: [1, 3, 5]
Conclusão
Arrays em Ruby são uma estrutura de dados fundamental que permite armazenar e manipular coleções de elementos de maneira eficiente. Você pode acessar, modificar e iterar sobre os elementos de arrays usando uma variedade de métodos e técnicas, o que facilita o trabalho com listas de dados em seus programas Ruby.

nome_do_array.push(valor) - Adiciona um valor na próxima posição do array.
nome_do_array.delete(valor) - Remove o valor especificado.
nome_do_vetor[posição]- Para ver o valor de uma determinada posição.

- HASHES: são uma estrutura de dados que armazena pares de chave-valor, onde cada chave é única e associada a um valor. Hashes são úteis para armazenar e acessar dados de forma eficiente. Eles são semelhantes a dicionários em outras linguagens de programação.

Criando Hashes
Você pode criar um hash de várias maneiras:

# Criando um hash vazio
empty_hash = {}

# Criando um hash com pares de chave-valor
person = {
  "name" => "Alice",
  "age" => 30,
  "city" => "New York"
}

# Usando símbolos como chaves (uma prática comum)
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}
Acessando e Modificando Valores
Para acessar ou modificar valores em um hash, você usa a chave correspondente:

person = { name: "Alice", age: 30, city: "New York" }

# Acessando um valor
puts person[:name]  # Saída: Alice

# Modificando um valor
person[:age] = 31
puts person[:age]   # Saída: 31

# Adicionando um novo par chave-valor
person[:occupation] = "Engineer"
puts person[:occupation]  # Saída: Engineer
Métodos Comuns de Hashes
Aqui estão alguns métodos úteis para trabalhar com hashes em Ruby:

keys: Retorna um array com todas as chaves do hash.

puts person.keys.inspect  # Saída: [:name, :age, :city, :occupation]
values: Retorna um array com todos os valores do hash.

puts person.values.inspect  # Saída: ["Alice", 31, "New York", "Engineer"]
each: Itera sobre cada par chave-valor no hash.

person.each do |key, value|
  puts "#{key}: #{value}"
end
# Saída:
# name: Alice
# age: 31
# city: New York
# occupation: Engineer
has_key?: Verifica se o hash contém uma chave específica.

puts person.has_key?(:age)  # Saída: true
puts person.has_key?(:salary)  # Saída: false
has_value?: Verifica se o hash contém um valor específico.

puts person.has_value?("Alice")  # Saída: true
puts person.has_value?(25)       # Saída: false
delete: Remove um par chave-valor do hash.

person.delete(:occupation)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"New York"}
merge: Mescla dois hashes, com o segundo hash sobrescrevendo valores do primeiro hash para chaves iguais.

new_info = { city: "San Francisco", email: "alice@example.com" }
person.merge!(new_info)
puts person.inspect  # Saída: {:name=>"Alice", :age=>31, :city=>"San Francisco", :email=>"alice@example.com"}
Hashes e Símbolos
Usar símbolos como chaves é uma prática comum em Ruby, pois os símbolos são mais eficientes em termos de desempenho e memória comparados às strings:

# Usando símbolos como chaves
person = {
  name: "Alice",
  age: 30,
  city: "New York"
}

# Acessando valores
puts person[:name]  # Saída: Alice
Hashes Aninhados
Você pode ter hashes dentro de hashes para representar estruturas de dados mais complexas:

people = {
  alice: { age: 30, city: "New York" },
  bob: { age: 25, city: "San Francisco" }
}
puts people[:alice][:city]  # Saída: New York

Conclusão
Hashes são uma ferramenta poderosa em Ruby para armazenar e organizar dados de forma eficiente. Eles permitem o acesso rápido a valores baseados em chaves e oferecem uma variedade de métodos para manipular e consultar os dados armazenados.

PRIMEIRA FORMA:
- criando um hash: h = { "a" => "123", "b" => "456" } 
- Acessando o valor de uma chave: h["a"].

SEGUNDA FORMA:
 - criando um hash: h = { a: "123", b: "456" }
 - Acessando o valor de uma chave: h[:a].

SÍMBOLOS: Definição 1: (São strings estáticas) 
Definição 2: Símbolos são objetos imutáveis e únicos que representam identificadores, nomes ou valores constantes. Usamos para criar hashes.

Sintaxe: Criados prefixando um nome com dois pontos (:), como :name, :age, :city.

Características:

Imutabilidade: Não podem ser alterados após a criação.
Identidade Única: Cada símbolo com o mesmo nome é o mesmo objeto na memória.
Eficiência: Comparações e armazenamento são mais eficientes do que para strings.
Usos Comuns:
Chaves de Hashes: Usados como chaves em hashes por sua eficiência.

person = { name: "Alice", age: 30, city: "New York" }
Parâmetros de Métodos: Representam opções ou parâmetros de métodos.

def greet(options = {})
  name = options[:name] || "Guest"
  puts "Hello, #{name}!"
end
Identificadores: Representam eventos ou mensagens.

event = :login_success
Comparação com Strings:

Imutabilidade: Strings podem ser alteradas, símbolos não.
Eficiência: Comparações e armazenamento são mais rápidos e econômicos para símbolos.
Exemplo de Comparação

# Comparando símbolos
symbol1 = :hello
symbol2 = :hello
puts symbol1.equal?(symbol2)  # Saída: true (mesmo objeto na memória)
Símbolos são ideais para representar valores constantes e identificadores devido à sua imutabilidade e eficiência.

.object_id - Retorna o endereço de memória de uma variável. EX: "Lucas".object_id -> Isso na primeira vez que foi executado retorna 13660, na segunda retornou 15500, ou seja o endereço sempre muda. Obs: se usarmos esse método com um símbolo, o endereço de memórianão muda.
Ex:
irb(main):009> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez.
irb(main):010> :abc.class.object_id
=> 37220 mesmo endereço de memória, mesmo executando mais de 1 vez. 


-ITERADOR EACH (mais usado no ruby do que o for): é uma maneira simples e poderosa de percorrer elementos de coleções, como arrays e hashes, e realizar uma operação para cada elemento.

Como Funciona
Para Arrays: O método each passa cada elemento do array para um bloco de código.

array = [1, 2, 3]
array.each do |element|
  puts element
end
Saída:
1
2
3

Explicação: O bloco (do |element| ... end) é executado para cada elemento do array, e element representa o item atual do array.

Para Hashes: O método each passa cada par chave-valor do hash para um bloco de código.

hash = { a: 1, b: 2, c: 3 }
hash.each do |key, value|
  puts "#{key}: #{value}"
end
Saída:

makefile
Copiar código
a: 1
b: 2
c: 3
Explicação: O bloco (do |key, value| ... end) é executado para cada par chave-valor do hash, onde key é a chave e value é o valor correspondente.

Resumo
each é usado para iterar sobre todos os elementos de uma coleção.
Array: Passa cada elemento para o bloco.
Hash: Passa cada par chave-valor para o bloco.
Uso: Ideal para aplicar uma operação a cada item sem modificar a coleção original.

MEU EXEMPLO: Esse código pega a que é o elemento do array, passe em cada um deles, e quando for passar em cada um deles chame de element e depois imprima-o na tela.

PRIMEIRA FORMA INLINE:
a = [1,4,6,89,0]
a.each { |element| puts element } 

SEGUNDA FORMA:
a.each do |el|
   puts el
   puts el * 2
   puts el * 3
 end